Sparse Bayesian Learning and the Relevance Vector Machine
Michael E. Tipping mtipping@microsoft.com
Microsoft Research
St George House, 1 Guildhal l Street
Cambridge CB2 3NH, U.K.
Editor: Alex Smola
Abstract
This paper introduces a general Bayesian framework for obtaining sparse solutions to regression and classiication tasks utilising models linear in the parameters. Although this
framework is fully general, we illustrate our approach with a particular specialisation that we denote the `relevance vector machine' (RVM), a model of identical functional form to
the popular and state-of-the-art `support vector machine' (SVM). We demonstrate that by
exploiting a probabilistic Bayesian learning framework, we can derive accurate prediction
models which typically utilise dramatically fewer basis functions than a comparable SVM
while o
ering a number of additional advantages. These include the beneits of probabilistic predictions, automatic estimation of `nuisance' parameters, and the facility to utilise
arbitrary basis functions (e.g. non-`Mercer' kernels).
We detail the Bayesian framework and associated learning algorithm for the RVM, and
give some illustrative examples of its application along with some comparative benchmarks.
We o
er some explanation for the exceptional degree of sparsity obtained, and discuss
and demonstrate some of the advantageous features, and potential extensions, of Bayesian
relevance learning.
1. Introduction
In supervised learning we are given a set of examples of input vectors fxngN
n=1 along with
corresponding targets ftngN
n=1, the latter of which might be real values (in regression)
Tipping
since the adjustable parameters (or `weights') w = (w1; w2;:::;wM )T appear linearly, and
the ob jective is to estimate `good' values for those parameters.
In this paper, we detail a Bayesian probabilistic framework for learning in general models
of the form (1). The key feature of this approach is that as well as o
ering good generalisation performance, the inferred predictors are exceedingly sparse in that they contain
relatively few non-zero wi parameters. The ma jority of parameters are automatically set to
zero during the learning process, giving a procedure that is extremely e
ective at discerning
those basis functions which are `relevant' for making good predictions.
While the range of models of the type (1) that we can address is extremely broad, we
concentrate here on a specialisation that we denote the `relevance vector machine' (RVM),
originally introduced by Tipping (2000). We consider functions of a type corresponding
to those implemented by another sparse linearly-parameterised model, the support vector
machine (SVM) (Boser et al., 1992; Vapnik, 1998; Scholkopf et al., 1999a). The SVM makes
predictions based on the function:
y(x; w) = X
N
i=1
wiK(x; xi) + w0; (2)
where K(x; xi) is a kernel function, e
ectively deining one basis function for each example
in the training set.1 The key feature of the SVM is that, in the classiication case, its target
function attempts to minimise a measure of error on the training set while simultaneously
maximising the `margin' between the two classes (in the feature space implicitly deined
by the kernel). This is a highly e
ective mechanism for avoiding over-itting, which leads
to good generalisation, and which furthermore results in a sparse model dependent only
on a subset of kernel functions: those associated with training examples xn (the \support
vectors") that lie either on the margin or on the `wrong' side of it. State-of-the-art results
have been reported on many tasks where the SVM has been applied.
However, despite its success, we can identify a number of signiicant and practical disadvantages of the support vector learning methodology:
 Although relatively sparse, SVMs make unnecessarily liberal use of basis functions
since the number of support vectors required typically grows linearly with the size of
the training set. Some form of post-processing is often required to reduce computational complexity (Burges, 1996; Burges and Scholkopf, 1997).
 Predictions are not probabilistic. In regression the SVM outputs a point estimate, and
in classiication, a `hard' binary decision. Ideally, we desire to estimate the conditional
distribution p(tjx) in order to capture uncertainty in our prediction. In regression this
may take the form of `error-bars', but it is particularly crucial in classiication where
posterior probabilities of class membership are necessary to adapt to varying class
priors and asymmetric misclassiication costs. Posterior probability estimates have
been coerced from SVMs via post-processing (Platt, 2000), although we argue that
these estimates are unreliable (Appendix D.2).
1. Note that the SVM predictor is not deined explicitly in this form | rather (2) emerges implicitly as a
consequence of the use of the kernel function to deine a dot-product in some notional feature space.
212
Sparse Bayesian Learning and the Relevance Vector Machine
 It is necessary to estimate the error/margin trade-o
 parameter `C' (and in regression,
the insensitivity parameter `' too). This generally entails a cross-validation procedure,
which is wasteful both of data and computation.  The kernel function K(x; xi) must satisfy Mercer's condition. That is, it must be the
continuous symmetric kernel of a positive integral operator.2
The `relevance vector machine' (RVM) is a Bayesian treatment
3 of (2) which does not
su
er from any of the above limitations. Speciically, we adopt a fully probabilistic framework and introduce a prior over the model weights governed by a set of hyperparameters,
one associated with each weight, whose most probable values are iteratively estimated from
the data. Sparsity is achieved because in practice we ind that the posterior distributions
of many of the weights are sharply (indeed ininitely) peaked around zero. We term those
training vectors associated with the remaining non-zero weights `relevance' vectors, in deference to the principle of automatic relevance determination which motivates the presented
approach (MacKay, 1994; Neal, 1996). The most compelling feature of the RVM is that,
while capable of generalisation performance comparable to an equivalent SVM, it typically
utilises dramatically fewer kernel functions.
In the next section, we introduce the Bayesian model, initially for regression, and deine
the procedure for obtaining hyperparameter values, and from them, the weights. The
framework is then extended straightforwardly to the classiication case in Section 3. In
Section 4, we give some visualisable examples of application of the RVM in both scenarios,
along with an illustration of some potentially powerful extensions to the basic model, before
o
ering some benchmark comparisons with the SVM. We o
er some theoretical insight into
the reasons behind the observed sparsity of the technique in Section 5 before summarising
in Section 6. To streamline the presentation within the main text, considerable theoretical
and implementational details are reserved for the appendices.
2. Sparse Bayesian Learning for Regression
We now detail the sparse Bayesian regression model and associated inference procedures.
The classiication counterpart is considered in Section 3.
2.1 Model Speciication
Given a data set of input-target pairs fxn; tngN
n=1, considering scalar-valued target functions
only, we follow the standard probabilistic formulation and assume that the targets are
samples from the model with additive noise:
tn = y(xn; w) + n; where n are independent samples from some noise process which is further assumed to be
mean-zero Gaussian with variance 2
. Thus p(tnjx) = N (tnjy(xn); 2
), where the notation
2. This restriction can be relaxed slightly to include conditional ly positive kernels (Smola et al., 1998;
Scholkopf, 2001).
3. Note that our approach is not a Bayesian treatment of the SVM methodology per se, an area which has
seen much recent interest (Sollich, 2000; Seeger, 2000; Kwok, 2000) | here we treat the kernel function
as simply deining a set of basis functions, rather than as a deinition of a dot-product in some space.
213
Tipping
speciies a Gaussian distribution over tn with mean y(xn) and variance 2
. The function
y(x) is as deined in (2) for the SVM where we identify our general basis functions with the
kernel as parameterised by the training vectors: i(x)  K(x; xi). Due to the assumption
of independence of the tn, the likelihood of the complete data set can be written as
p(tjw; 2
) = (22
)N=2 exp 
1
22 kt  wk
2
; (4)
where t = (t1 :::tN )T
, w = (w0 :::wN )T and  is the N (N + 1) `design' matrix with  =
[(x1); (x2);:::; (xN )]T
, wherein (xn) = [1; K(xn; x1); K(xn; x2);:::;K(xn; xN )]T
. For
clarity, we omit to notate the implicit conditioning upon the set of input vectors fxng in
(4) and subsequent expressions.
With as many parameters in the model as training examples, we would expect maximumlikelihood estimation of w and 2
from (4) to lead to severe over-itting. To avoid this, a
common approach is to impose some additional constraint on the parameters, for example,
through the addition of a `complexity' penalty term to the likelihood or error function. This
is implicitly e
ected by the inclusion of the `margin' term in the SVM. Here, though, we
adopt a Bayesian perspective, and `constrain' the parameters by deining an explicit prior
probability distribution over them.
We encode a preference for smoother (less complex) functions by making the popular
choice of a zero-mean Gaussian prior distribution over w:
p(wj
) = Y
N
i=0
N (wij0; 
1
i ); (5)
with 
 a vector of N + 1 hyperparameters. Importantly, there is an individual hyperparameter associated independently with every weight, moderating the strength of the prior
thereon.4
To complete the speciication of this hierarchical prior, we must deine hyperpriors
over 
, as well as over the inal remaining parameter in the model, the noise variance 2
. These quantities are examples of scale parameters, and suitable priors thereover are Gamma
distributions (see, e.g., Berger, 1985):
p(
) = Y
N
i=0
Gamma(
i ja; b);
p(i) = Gamma(ijc; d); with i  2 and where
Gamma(
ja; b) = (a)1b
a
a1eb

; (6)
with (a) = R 1
0
ta1etdt, the `gamma function'. To make these priors non-informative (i.e.

at), we might ix their parameters to small values: e.g. a = b = c = d = 104
. However, by
4. Note that although it is not a characteristic of this parameter prior in general, for the case of the RVM
that we consider here, the overall implied prior over functions is data dependent due to the appearance
of xn in the basis functions K(x; xn). This presents no practical diculty, although we must take care in
interpreting the \error-bars" implied by the model. In Appendix D.1 we consider this in further
Sparse Bayesian Learning and the Relevance Vector Machine
setting these parameters to zero, we obtain uniform hyperpriors (over a logarithmic scale).
Since all scales are equally likely, a pleasing consequence of the use of such `improper'
hyperpriors here is that of scale-invariance: predictions are independent of linear scaling of
both t and the basis function outputs so, for example, results do not depend on the unit
of measurement of the targets. For completeness, the more detailed derivations o
ered in
Appendix A will consider the case of general Gamma priors for 
 and i, but in the main
body of the paper, all further analysis and presented results will assume uniform scale priors
with a = b = c = d = 0.
This formulation of prior distributions is a type of automatic relevance determination
(ARD) prior (MacKay, 1994; Neal, 1996). Using such priors in a neural network, individual
hyperparameters would typically control groups of weights | those associated with each
input dimension x (this idea has also been applied to the input variables in `Gaussian
process' models). Should the evidence from the data support such a hypothesis, using a
broad prior over the hyperparameters allows the posterior probability mass to concentrate
at very large values of some of these 
 variables, with the consequence that the posterior
probability of the associated weights will be concentrated at zero, thus e
ectively `switching
o
 ' the corresponding inputs, and so deeming them to be `irrelevant'.
Here, the assignment of an individual hyperparameter to each weight, or basis function,
is the key feature of the relevance vector machine, and is responsible ultimately for its
sparsity properties. To introduce an additional N + 1 parameters to the model may seem
counter-intuitive, since we have already conceded that we have too many parameters, but
from a Bayesian perspective, if we correctly `integrate out' all such `nuisance' parameters
(or can approximate such a procedure suciently accurately), then this presents no problem
from a methodological perspective (see Neal, 1996, pp. 16{17). Any subsequently observed
`failure' in learning is attributable to the form, not the parameterisation, of the prior over
functions.
2.2 Inference
Having deined the prior, Bayesian inference proceeds by computing, from Bayes' rule, the
posterior over all unknowns given the data:
p(w; 
; 2
jt) = p(tjw; 
; 2
)p(w; 
; 2
)
p(t)
: (7)
Then, given a new test point, x, predictions are made for the corresponding target t, in
terms of the predictive distribution:
p(tjt) = Z
p(tjw; 
; 2
) p(w; 
; 2
jt) dw d
 d2
: (8)
To those familiar, or even not-so-familiar, with Bayesian methods, it may come as no surprise
to learn that we cannot perform these computations in full analytically, and must seek an
e
ective approximation.
We cannot compute the posterior p(w; 
; 2
jt) in (7) directly since we cannot perform
the normalising integral on the right-hand-side, p(t) = R p(tjw; 
; 2
)p(w; 
; 2
) dw d
 d2
. Instead, we decompose the posterior as:
p(w; 
; 2
jt) = p(wjt; 
; 2
)p(
; 2
jt); (9)
215
Tipping
and note that we can compute analytically the posterior distribution over the weights since
its normalising integral, p(tj
; 2
) = R p(tjw; 2
) p(wj
) dw, is a convolution of Gaussians.
The posterior distribution over the weights is thus given by:5
p(wjt; 
; 2
) = p(tjw; 2
)p(wj
)
p(tj
; 2
)
; (10)
= (2)(N+1)=2
jj1=2 exp 
1
2
(w  )T1
(w  )
; (11)
where the posterior covariance and mean are respectively:
 = (2T + A)1
; (12)
 = 2T
t; (13)
with A = diag(
0; 
1;:::;
N ).
We are now forced to adopt some approximation, and do so by representing the second
term on the right-hand-side in (9), the hyperparameter posterior p(
; 2
jt), by a deltafunction at its mode6
, i.e. at its most-probable values 
MP; 2
MP. We do so on the basis that
this point-estimate is representative of the posterior in the sense that functions generated
utilising the posterior mode values are near-identical to those obtained by sampling from
the full posterior distribution. It is important to realise that this does not necessitate that
the entire mass of the posterior be accurately approximated by the delta-function. For
predictive purposes, rather than requiring p(
; 2
jt)  (
MP; 2
MP), we only desire
Z
p(tj
; 2
)(
MP; 2
MP) d
 d2 
Z
p(tj
; 2
)p(
; 2
jt) d
 d2
; (14)
to be a good approximation. This notion may be visualised by a thought experiment where
we consider that we are utilising two identical basis functions i(x) and j (x). It follows
from (15) shortly that the mode of p(
; 2
jt) will not be unique, but will comprise an ininite
`ridge' where 
1
i + 
1
j
is some constant value. No delta-function can be considered to
reasonably approximate the probability mass associated with this ridge, yet any point along
it implies an identical predictive distribution and so (14) holds. All the evidence from the
experiments presented in this paper suggests that this predictive approximation is very
e
ective in general.
Relevance vector `learning' thus becomes the search for the hyperparameter posterior
mode, i.e. the maximisation of p(
; 2
jt) / p(tj
; 2
)p(
)p(2
) with respect to 
 and i.
5. Rather than evaluating (10) explicitly, there is a quicker way to obtain both the weight posterior (11)
and the marginal likelihood (15) together. From Bayes rule simply write p(wjt; 
; 2
)p(tj
; 2
) =
p(tjw; 2
)p(wj
). Then, expanding the known right-hand-side quantities, gather together all terms in w that appear within the exponential, and complete the square, introducing some new terms in t, to
give by inspection the posterior Gaussian distribution p(wjt; 
; 2
). Combining all the remaining terms
in t then gives p(tj
; 2
) (15).
6. An alternative approach is to iteratively maximise a variational lower bound on p(t), via a factorised
approximation to p(w; 
; 2
jt), the joint posterior distribution over all the model parameters (Bishop
and Tipping, 2000). This is a computationally intensive technique and in practice gives expected values
for the hyperparameters which are identical to the point-estimates obtained by the method described
Sparse Bayesian Learning and the Relevance Vector Machine
For the case of uniform hyperpriors (we consider the general case in Appendix A), we need
only maximise the term p(tj
; 2
), which is computable and given by:
p(tj
; 2
) = Z
p(tjw; 2
)p(wj
) dw; = (2)N=2
j2I + A1T
j1=2 exp 
1
2
tT
(2I + A1T
)1t
: (15)
In related Bayesian models, this quantity is known as the marginal likelihood, and its maximisation known as the type-II maximum likelihood method (Berger, 1985). The marginal
likelihood is also referred to as the \evidence for the hyperparameters" by MacKay (1992a),
and its maximisation as the \evidence procedure".
2.3 Optimising the Hyperparameters
Values of 
 and 2 which maximise (15) cannot be obtained in closed form, and here we
summarise formulae for their iterative re-estimation. Further details concerning hyperparameter estimation, including alternative expectation-maximisation-based re-estimates, are
given in Appendix A.
For 
, di
erentiation of (15), equating to zero and rearranging, following the approach
of MacKay (1992a), gives:

new
i =

i
2
i ; (16)
where i is the i-th posterior mean weight from (13) and we have deined the quantities 
i
by:

i  1  
iii; with ii the i-th diagonal element of the posterior weight covariance from (12) computed
with the current 
 and 2 values. Each 
i 2 [0; 1] can be interpreted as a measure of how
`well-determined' its corresponding parameter wi is by the data (MacKay, 1992a). For 
i
large, where wi is highly constrained by the prior, ii  
1
i and it follows that 
i  0.
Conversely, when 
i is small and wi its the data, 
i  1.
For the noise variance 2
, di
erentiation leads to the re-estimate:
(2
)new =
kt  k2
N  P
i 
i : (18)
Note that the `N' in the denominator refers to the number of data examples and not the
number of basis functions.
The learning algorithm thus proceeds by repeated application of (16) and (18), concurrent with updating of the posterior statistics  and  from (12) and (13), until some
suitable convergence criteria have been satisied (see Appendix A for some further implementation details). In practice, during re-estimation, we generally ind that many of the

i tend to ininity (or, in fact, become numerically indistinguishable from ininity given the
machine accuracy)7
. From (11), this implies that p(wijt; 
; 2
) becomes highly (in princi7. This is true only for the case of the uniform hyperparameter priors adopted here. The use of more general
Gamma priors, detailed in the appendix, would typically lead to some 
's taking on large, but inite, values, and so implying some small, but non-zero, weights. Sparsity would then be realised through
thresholding of the wei
Tipping
ple, ininitely) peaked at zero | i.e. we are a posteriori `certain' that those wi are zero.
The corresponding basis functions can thus be `pruned', and sparsity is realised.
2.4 Making Predictions
At convergence of the hyperparameter estimation procedure, we make predictions based on
the posterior distribution over the weights, conditioned on the maximising values 
MP and
2
MP. We can then compute the predictive distribution, from (8), for a new datum x using
(11):
p(tjt; 
MP; 2
MP) = Z
p(tjw; 2
MP)p(wjt; 
MP; 2
MP) dw: (19)
Since both terms in the integrand are Gaussian, this is readily computed, giving:
p(tjt; 
MP; 2
MP) = N (tjy; 2
 ); with
y = T(x); (21)
2
 = 2
MP + (x)T(x): (22)
So the predictive mean is intuitively y(x; ), or the basis functions weighted by the posterior mean weights, many of which will typically be zero. The predictive variance (or
`error-bars') comprises the sum of two variance components: the estimated noise on the
data and that due to the uncertainty in the prediction of the weights. In practice, then,
we may thus choose to set our parameters w to ixed values  for the purposes of point
prediction, and retain  if required for computation of error bars (see Appendix D.1).
3. Sparse Bayesian Classiication
Relevance vector classiication follows an essentially identical framework as detailed for
regression in the previous section. We simply adapt the target conditional distribution
(likelihood function) and the link function to account for the change in the target quantities.
As a consequence, we must introduce an additional approximation step in the algorithm.
For two-class classiication, it is desired to predict the posterior probability of membership of one of the classes given the input x. We follow statistical convention and generalise
the linear model by applying the logistic sigmoid link function (y)=1=(1 + ey
) to y(x)
and, adopting the Bernoulli distribution for P (tjx), we write the likelihood as:
P (tjw) = Y
N
n=1
fy(xn; w)g
tn
[1  fy(xn; w)g]1tn
; (23)
where, following from the probabilistic speciication, the targets tn 2 f0; 1g. Note that there
is no `noise' variance here.
However, unlike the regression case, we cannot integrate out the weights analytically, and so are denied closed-form expressions for either the weight posterior p(wjt; 
) or the
marginal likelihood P (tj
). We thus choose to utilise the following approximation procedure, as used by MacKay (1992b), which is based on Laplace's method:

Sparse Bayesian Learning and the Relevance Vector Machine
1. For the current, ixed, values of 
, the `most probable' weights wMP are found, giving
the location of the mode of the posterior distribution.
Since p(wjt; 
) / P (tjw)p(wj
), this is equivalent to inding the maximum, over w, of
log fP (tjw)p(wj
)g = X
N
n=1
[tn log yn + (1  tn) log(1  yn)]
1
2
wTAw; (24)
with yn = fy(xn; w)g. This is a standard procedure, since (24) is a penalised
(regularised) logistic log-likelihood function, and necessitates iterative maximisation.
Second-order Newton methods may be e
ectively applied, since the Hessian of (24),
required next in step 2, is explicitly computed. We adapted the ecient `iterativelyreweighted least-squares' algorithm (e.g. Nabney, 1999) to ind wMP.
2. Laplace's method is simply a quadratic approximation to the log-posterior around its
mode. The quantity (24) is di
erentiated twice to give:
rwrw log p(wjt; 
)
i
iwMP= (TB + A); (25)
where B = diag (i1; i2;:::;iN ) is a diagonal matrix with in = fy(xn)g [1  fy(xn)g].
This is then negated and inverted to give the covariance  for a Gaussian approximation to the posterior over weights centred at wMP.
3. Using the statistics  and wMP (in place of ) of the Gaussian approximation, the
hyperparameters 
 are updated using (16) in identical fashion to the regression case.
At the mode of p(wjt; 
), using (25) and the fact that rw log p(wjt; 
)
i
iwMP= 0, we can
write:
 = (TB + A)1
; (26)
wMP = TBt: (27)
These equations are equivalent to the solution to a `generalised least squares' problem
(e.g. Mardia et al., 1979, p.172). Compared with (12) and (13), it can be seen that the
Laplace approximation e
ectively maps the classiication problem to a regression one with
data-dependent (heteroscedastic) noise, with the inverse noise variance for n given by
in = fy(xn)g [1  fy(xn)g].
How accurate is the Laplace approximation? In the Bayesian treatment of multilayer
neural networks, the Gaussian approximation is considered a weakness of the method as
the single mode of p(wjt; 
) at wMP can often be unrepresentative of the overall posterior
mass, particularly when there are multiple such modes (as is often the case). Here in
this linearly-parameterised model, we know that p(wjt; 
) is log-concave (as the Hessian is
negative-deinite everywhere). Not only is the posterior thus unimodal, log-concavity also
implies that its tails are no heavier than exp(jwj), and so we expect much better accuracy.8
8. An alternative Gaussian approximation is realisable using the variational bound of Jaakkola and Jordan
(1997), exploited in the variational RVM (Bishop and Tipping, 200
Tipping
For polychotomous classiication, where the number of classes K is greater than two,
the likelihood (23) is generalised to the standard multinomial form:
P (tjw) = Y
N
n=1
Y
K
k=1
fyk(xn; wk)g
tnk
; (28)
where a conventional \one-of-K" target coding for t is used and the classiier has multiple
outputs yk(x; wk), each with its own parameter vector wk and associated hyperparameters

k (although the hyperparameters could be shared amongst outputs if desired). The modiied Hessian is computed from this (see Nabney, 1999) and inference proceeds as shown
above. There is no need to heuristically combine multiple classiiers as is the case with, for
example, the SVM. However, the size of  scales with K, which is a highly disadvantageous
consequence from a computational perspective.
4. Relevance Vector Examples
In this section we irst present some visualisations of the relevance vector machine applied
to simple example synthetic data sets in both regression (Section 4.1) and classiication
(Section 4.2), followed by another synthetic regression example to demonstrate some potential extensions of the approach (Section 4.3). We then o
er some illustrative `benchmark'
results in Section 4.4.
4.1 Relevance Vector Regression: the `sinc' function
The function sinc(x) = sin(x)=x has been a popular choice to illustrate support vector
regression (Vapnik et al., 1997; Vapnik, 1998), where in place of the classiication margin,
the -insensitive region is introduced, a `tube' of  around the function within which errors
are not penalised. In this case, the support vectors lie on the edge of, or outside, this region.
For example, using a univariate `linear spline' kernel:
K(xm; xn) = 1+ xmxn + xmxn min(xm; xn)
xm + xn 2
min(xm; xn)
2 +
min(xm; xn)
3
3
; (29)
and with  = 0:01, the approximation of sinc(x) based on 100 uniformly-spaced noise-free
samples in [10; 10] utilises 36 support vectors as shown in Figure 1 (left).
In the RVM, we model the same data with the same kernel (29), which is utilised to
deine a set of basis functions n(x) = K(x; xn), n = 1 :::N. Typically, we will be tackling
problems where the target function has some additive noise component, the variance of
which we attempt to estimate with 2
. However, for the purposes of comparison with
this `function approximation' SVM example, we model the `sinc' function with a relevance
vector machine but ix the noise variance in this case at 0:012 and then re-estimate 

alone. This setting of the noise standard deviation to 0:01 is intended to be analogous,
in an approximate sense, to the setting the -insensitivity to the same value in the SVM.
Using this ixed , the RVM approximator is plotted in Figure 1 (right), and requires only
9 relevance vectors. The largest error is 0.0070, compared to 0.0100 in the support vector
case, and we have obtained the dual beneit of both increased accuracy and sparsity.
2
Sparse Bayesian Learning and the Relevance Vector Machine
More representative of `real' problems, Figure 2 illustrates the case where uniform noise
(i.e. not corresponding to the RVM noise model) in [0:2; 0:2] is added to the targets. Again,
a linear spline kernel was used. The trained RVM uses 6 relevance vectors, compared to 29
for the SVM. The root-mean-square (RMS) deviation from the true function for the RVM
is 0.0245, while for the SVM it is 0.0291. Note that for the latter model, it was necessary to
tune the parameters C and , in this case using 5-fold cross-validation. For the RVM, the
analogues of these parameters (the 
's and 2
) are automatically estimated by the learning
procedure.
-10 -5 0 5 10
-0.2
0
0.2
0.4
0.6
0.8
1
1.2
-10 -5 0 5 10
-0.2
0
0.2
0.4
0.6
0.8
1
1.2
Figure 1: Support (left) and relevance (right) vector approximations to sinc(x) from 100
noise-free examples using `linear spline' basis functions. The estimated functions
are drawn as solid lines with support/relevance vectors shown circled.
-10 -5 0 5 10
-0.4
-0.2
0
0.2
0.4
0.6
0.8
1
-10 -5 0 5 10
-0.4
-0.2
0
0.2
0.4
0.6
0.8
1
Figure 2: Support (left) and relevance (right) vector approximations to sinc(x), based on
100 noisy samples. The estimated functions are drawn as solid lines, the true
function in grey, and support/relevance vectors are again shown circled.
22
Tipping
4.2 Relevance Vector Classiication: Ripley's synthetic data
We utilise artiicially-generated data in two dimensions in order to illustrate graphically
the selection of relevance vectors for classiication. Both class 1 (denoted by `') and class
2 (`') were generated from mixtures of two Gaussians by Ripley (1996), with the classes
overlapping to the extent that the Bayes error is around 8%.
A relevance vector classiier is compared to its support vector counterpart, using a
`Gaussian' kernel which we deine as
K(xm; xn) = exp(r2kxm  xnk
2
); (30)
with r the `width' parameter, chosen here to be 0.5. A value of C for the SVM was selected
using 5-fold cross-validation on the training set. The results for a 100-example training set
(randomly chosen from Ripley's original 250) are given in Figure 3. The test error (from
the associated 1000-example test set) for the RVM (9.3%) is slightly superior to the SVM
(10.6%), but the remarkable feature of contrast is the complexity of the classiiers. The
support vector machine utilises 38 kernel functions compared to just 4 for the relevance
vector method. This considerable di
erence in sparsity between the two methods is typical,
as the later results on benchmark data sets support.
Figure 3: SVM (left) and RVM (right) classiiers on 100 examples from Ripley's Gaussianmixture data set. The decision boundary is shown dashed, and relevance/support
vectors are shown circled to emphasise the dramatic reduction in complexity of
the RVM model.
Of interest also is the fact that, unlike for the SVM, the relevance vectors are some
distance from the decision boundary (in x-space), appearing more `prototypical' or even
`anti-boundary' in character. Given further analysis, this observation can be seen to be
consistent with the hyperparameter update equations given the form of the posterior induced by the Laplace approximation of Section 3. A more qualitative explanation is that
the output of a basis function centred on or near the decision boundary is an unreliable

Sparse Bayesian Learning and the Relevance Vector Machine
indicator of class membership (i.e. its output is poorly-aligned with the data set in t-space
| see Section 5.2 for an illustration of this concept), and such basis functions are naturally
penalised (deemed `irrelevant') under the Bayesian framework. Of course, there is no implication that the utilisation of either boundary-located or prototypically-located functions
is `correct' in any sense.
4.3 Extensions
Before giving some example results on benchmark data sets, we use another synthetic example to demonstrate the potential of two advantageous features of the sparse Bayesian
approach: the ability to utilise arbitrary basis functions, and the facility to directly `optimise' parameters within the kernel speciication, such as those which moderate the input
scales.
This latter feature is of considerable importance: in both the SVM and RVM, it is
necessary to choose the type of kernel function, and also to determine appropriate values
for any associated parameters | e.g. the input scale (width) parameter9  = r2 of the
Gaussian kernel (30). In the examples of Section 4.4 which follow,  is estimated by crossvalidation for both the SVM and the RVM. This is a sensible and practical approach for a
single such parameter, but is inapplicable if it is desired to associate an individual i with
each input variable. Use of such multiple input scale parameters within kernels (or other
basis functions) is inherently sensible, and as will be seen, can be an e
ective way of dealing
with irrelevant input variables.
Consider now the problem of estimating the following, quite simple, two-dimensional
function
y(x1; x2) = sinc(x1)+0:1x2; based on 100 examples with additive Gaussian noise of standard deviation 0.1. There are
two evident problems with direct application of a support or relevance vector model to this
data:
 The function is linear in x2, but this will be modelled rather unsatisfactorily by a
superposition of nonlinear functions.
 The nonlinear element, sinc(x1), is a function of x1 alone, and so x2 will simply add
irrelevant `noise' to the input, and thus output, of the basis functions and this will be
re
ected in the overall approximator.
These two features make the function dicult to learn accurately, and the function along
with its SVM approximation (the RVM gives similar, only marginally superior, results here)
is shown in Figure 4.
To improve upon the results shown in Figure 4 (right), we implement two modiications.
We emphasised earlier that the RVM is really a specialisation of a Bayesian procedure
deined for arbitrary basis sets and as such we are free to modify the type and number of
9. In the Gaussian kernel, this input scale parameter is explicit, but all non-trivial kernel functions, even
those which do not typically incorporate such a parameter, are sensitive to the scaling of the input variables. As such, there may be considered to be an input scale parameter i associated with each input
dimension, even if these are all implicitly assumed to be equal to unity.
22
Tipping
-10
-5
0
5
10
-10
-5
0
5
10
-1.5
-1
-0.5
0
0.5
1
1.5
2
x1
x2
-10
-5
0
5
10
-10
-5
0
5
10
-1.5
-1
-0.5
0
0.5
1
1.5
2
x1
x
2
Figure 4: LEFT: the function sinc(x1)+0:1x2 along with the training data, and RIGHT:
its approximation by a support vector model with a Gaussian kernel (r = 3).
basis functions that we feel might be useful in a given problem. Here, mirroring the general
approach sometimes taken in Gaussian process regression (Rasmussen, 1996), we introduce
the input variables as two extra `functions'. This is achieved by simply appending two
extra columns to the design matrix  containing the x1 and x2 values, and introducing
corresponding weights and hyperparameters which are updated identically to all others.
We would hope that the weight associated with x1 would be zero (and indeed, would be
pruned), while that corresponding to x2 should be approximately 0:1. In fact, to complicate
the problem further here, we also introduced three additional quadratic terms x2
1, x2
2 and
x1x2 which we hope to similarly prune.
A second modiication is to directly optimise the marginal likelihood with respect to the
kernel input scale parameters. For this problem we thus introduce the parameters 1 and
2 such that the kernel function becomes
K(xm; xn) = exp 1(xm1  xn1)
2  2(xm2  xn2)
2	
: (31)
To estimate these parameters, at each iteration of the hyperparameter updates (16) a cycle
of maximisation of the marginal likelihood (15) with respect to 1 and 2 was performed
(using a gradient-based method). We give further implementation details in Appendix C.
Given these two modiications then, the inal, and much more accurate, RVM approximating function is shown in Figure 5. The error and sparsity of this modiied model is
compared with the SVM in Table 1 and the estimates of the `interesting' RVM parameters
are shown in Table 2.
While Figure 4 and Table 1 indicate both qualitatively and quantitatively the improvement obtained with the modiied RVM, Table 2 conirms that this is as a result of the
model learning the `correct' values of the newly introduced parameters. First, w2 is a good
approximation of the true function's value while all other candidates have been pruned.
Second, 2  1, such that K(xm; xn)  exp 1(xm1  xn1)
2	
and the basis functions
depend approximately on input variable x1 alone. One might fear that this procedure coul
Sparse Bayesian Learning and the Relevance Vector Machine
-10
-5
0
5
10
-10
-5
0
5
10
-2
-1
0
1
2
3
Figure 5: Approximation by a relevance vector model, with additional linear inputs and
optimisation of the input scales. The noise estimate was  = 0:101.
Model error # functions
SVM 0.0194 75
RVM 0.0053 8
Table 1: Root-mean-square error and number of basis functions required in approximation
of the function sin(x1)=x1 + 0:1x2, using an SVM, and an RVM with additional
linear input functions and optimised input scale parameters.
Parameter estimate
wx1 0
wx2 0.102
wx2
1 0
wx2
2 0
wx1x2 0
Parameter estimate
1  104 997
2  104 2
Table 2: LEFT: RVM parameter estimates for the weights associated with the additional
basis functions. RIGHT: estimates of the two scale parameters.
`over-it' and set all the i to large values (i.e. shrink all the `widths' in the Gaussian towards
zero). We o
er some schematic insight into why this does not occur in Section 5.2.
Finally, we underline that these additional parameters have been successfully estimated
directly from the training set, of 100 noisy samples, at the same time as estimating all other
model parameters, including the data noise level. No cross-validation was required.
225
Tipping
Although the above result is quite compelling, we must state some limitations to the
approach:
 The interleaved two-stage training procedure leaves open the question of how exactly
to combine optimisation over 
 and  (see Appendix C).
 The optimisation is computationally complex. While we can generally apply it to a
single given data set, it was only practical to apply it to a single benchmark experiment
in the following subsection.
4.4 Benchmark Comparisons
The tables which follow summarise regression and classiication performance of the relevance
vector machine on some example `benchmark' data sets, comparing results for illustrative
purposes with equivalent support vector machines. The number of training examples (N)
and the number of input variables (d) are given for each data set, with further details
regarding the data given in Appendix E. The prediction error obtained and the number
of vectors (support or relevance) required, generally averaged over a number of repetitions,
are given for both models. By way of summary, the RVM statistics were also normalised by
those of the SVM and the overall average is displayed. A Gaussian kernel was utilised, and
in all but a single case detailed shortly, its single input scale parameter chosen by 5-fold
cross-validation.
4.4.1 Regression
errors vectors
Data set N d SVM RVM SVM RVM
Sinc (Gaussian noise) 100 1 0.378 0.326 45.2 6.7
Sinc (Uniform noise) 100 1 0.215 0.187 44.3 7.0
Friedman #2 240 4 4140 3505 110.3 6.9
Friedman #3 240 4 0.0202 0.0164 106.5 11.5
Boston Housing 481 13 8.04 7.46 142.8 39.0
Normalised Mean 1.00 0.86 1.00 0.15
For the Friedman #1 data set, an additional benchmark result was obtained where the ten
input scale parameters of the Gaussian kernel were optimised in the RVM: this is designated
as `-RVM' below.
errors vectors
Data set N d SVM RVM -RVM SVM RVM -RVM
Friedman #1 240 10 2.92 2.80 0.27 116.6 59.4 11.5
The dramatic improvement of -RVM is a consequence of the fact that the target function,
as deliberately constructed by Friedman (1991), does not depend on input variables 6 to 10,
and the in
uence of those distractor variables is suppressed by very low estimates for the
corresponding k parameters. Unfortunately, computational resources limit the repetition
of this extended -optimisation procedure for the complete set of benchmark experiments
226
Sparse Bayesian Learning and the Relevance Vector Machine
presented here. Typically, however, we do observe improvements in individual regression
and classiication experiments, although not generally as dramatic as that shown above.
4.4.2 Classification
Some examples of classiication performance are given in the table below, and further details
of the data are given in Appendix E. All problems are two-class, with the exception of the
`U.S.P.S.' handwritten digit set where, for computational reasons, we mirrored the SVM
strategy of training ten separate dichotomous classiiers (rather than use the multinomial
likelihood).
errors vectors
Data set N d SVM RVM SVM RVM
Pima Diabetes 200 8 20.1% 19.6% 109 4
U.S.P.S. 7291 256 4.4% 5.1% 2540 316
Banana 400 2 10.9% 10.8% 135.2 11.4
Breast Cancer 200 9 26.9% 29.9% 116.7 6.3
Titanic 150 3 22.1% 23.0% 93.7 65.3
Waveform 400 21 10.3% 10.9% 146.4 14.6
German 700 20 22.6% 22.2% 411.2 12.5
Image 1300 18 3.0% 3.9 % 166.6 34.6
Normalised Mean 1.00 1.08 1.00 0.17
5. Perspectives on Sparsity
Both the illustrative and benchmark examples indicate that the presented Bayesian learning
procedure is capable of producing highly sparse models. The purpose of this section is to
o
er further insight into the causes of this sparsity, and to this end we irst look in more
detail at the form of the weight prior distribution. Following that, we adopt a Gaussian
process perspective in order to give a more graphical explanation.
5.1 The Prior over the Weights
From the Bayesian viewpoint, the relevance vector machine is sparse since most posterior
probability mass is distributed over solutions with small numbers of basis functions, and
the given learning algorithm inds one such solution. That sparse solutions are likely a
posteriori relies of course on the prior: there must also be signiicant probability on sparse
models a priori. Given the Gaussian speciication of p(wj
), though, it does not appear
that we are utilising such a prior. However, the hierarchical nature of the prior disguises
its overall character, and we need to integrate out the hyperparameters to discover the true
identity of the prior over the weights.
In Section 2, the marginal likelihood (15) was obtained by marginalising over the weights.
Alternatively, for a Gamma prior over the hyperparameters, it is also possible to integrate
out 
 instead, independently for each weight, to obtain the marginal, or what might be
227
Tipping
considered the `true', weight prior:
p(wi) = Z
p(wij
i)p(
i) d
i ; =
b
a(a + 1
2
)
(2)
1
2 (a)
(b + w2
i =2)(a+ 1
2 )
; (32)
where () is the gamma function as deined earlier. Equation (32) corresponds to the
density of a Student-t distribution, and so the overall marginal weight prior is a product
of independent Student-t distributions over the wi. A visualisation of this Student-t prior,
alongside a Gaussian, is given in Figure 6. For the case of the uniform hyperprior, with
a = b = 0, we obtain the improper prior p(wi) / 1=jwi j. Intuitively, this looks very
much like a `sparse' prior since it is sharply peaked at zero like the popular Laplace prior
p(wi) / exp (jwij), which has been utilised to obtain sparsity both in Bayesian contexts
(Williams, 1995), and, taking the negative log, as the `L1' regulariser P
i jwi j elsewhere (e.g.
Chen et al., 1995; Grandvalet, 1998; Smola et al., 1999). The implication is that although
supericially we appear to be utilising a non-sparse Gaussian prior over the weights, in truth
the hierarchical formulation implies that the real weight prior is one which can be clearly
recognised as encouraging sparsity.
0
0
Gaussian
0
0
0
0
Student-t
0
0
Figure 6: LEFT: an example Gaussian prior p(wj
) in two dimensions. RIGHT: the prior
p(w), where the hyperparameters have been integrated out to give a product of
Student-t distributions. Note that the probability mass is concentrated both at
the origin and along `spines' where one of the two weights is zero.
Unfortunately, we cannot continue the Bayesian analysis down this route to compute
p(wjt), since the marginal p(w) is no longer Gaussian. However, we might pose the question:
why not integrate out 
 explicitly and maximise over w | i.e. ind the mode of p(wjt) |
instead of vice-versa as detailed in Section 2? This alternative approach would be equivalent
Sparse Bayesian Learning and the Relevance Vector Machine
to maximisation of a penalised likelihood function of the form:
L(w) =
i
2 X
N
n=1
[tn  wT(xn)]2 X
N
i=0
log jwij; (33)
where we note that the presence of the log di
erentiates (33) from L1 regularisation. In
fact, we must discount this alternative inference strategy since we typically ind that L(w),
and so p(wjt), is signiicantly multi-modal, often extremely so. These modes occur where
the likelihood, which has the form of a Gaussian in w-space, overlaps the `spines' (see
Figure 6, right) of the prior. (We remind the reader here that the 
-conditional posterior,
p(wjt; 
), which we maximise in step 1 of the classiication case in Section 3, is log concave
and unimodal.) The implication therefore is that the marginalised weight posterior mode is
highly unrepresentative of the distribution of posterior probability mass. A good illustration
of this phenomenon is given by MacKay (1999) in the context of single-hyperparameter
models. Conversely, as discussed in Section 2.2, all the experimental evidence for relevance
vector learning suggests that 
MP is representative of the posterior p(
jt).
We inally note here that a model with a single hyperparameter governing the inverse
prior variance of al l weights would place less probability on sparse models than the `relevance' prior we use here. Such a prior does not specify independence over the weights,
the magnitudes of which are therefore coupled to all other weights through the common
hyperparameter (so, a priori, two large weights would be more probable than one large and
one small, for example).
5.2 A Gaussian Process View
We irst note that relevance vector learning in regression is maximising the probability of
the N-dimensional vector of target values t under the model of (15). This is a Gaussian
process model (Rasmussen, 1996; MacKay, 1998; Williams, 1999): i.e. p(t) = N (tj0; C)
where we re-write C from (15) as:
C = 2I +X
N
i=0

1
i vivT
i ; (34)
and vi = (i(x1); i (x2);:::;i(xN ))T
is an N-vector containing the output of basis function
i evaluated at all the training examples (whereas (x) earlier denoted the vector of all the
basis functions evaluated at a single datum). This implicit, `weightless', formulation of the
Bayesian model can be adopted explicitly in other contexts to realise sparsity, for example
in `sparse kernel PCA' (Tipping, 2001). In Figure 7 we illustrate schematically an idealised
two-dimensional `pro jection' of the Gaussian process.
The basis functions vi specify directions in t-space whose outer product contribution
to the overall covariance is modulated by the inverse hyperparameters 
1
i . Adjustment of
each 
i thus changes both the size and shape of C, while adjusting 2 grows or shrinks it
equally in all directions. The RVM learning procedure iteratively updates the noise level
along with all the contributions of the vectors vi in order to make the observed data set t
most probable.
Tipping
Figure 7: A Gaussian process view of the regression RVM, showing a two-dimensional `projection' of the N-dimensional data set space. The data set to be modelled is
marked with the cross, the weighted directions of some of the N basis vectors are
shown by grey arrows emanating from the origin, the noise component of the covariance is denoted by a dashed grey circle, and the form of the overall covariance
C is illustrated by the ellipse.
To see how sparsity can arise, consider, then, a trivial example with just a single basis
function v1, which is not well `aligned' with t. In Figure 8 (left), one possible C is shown
where v1 contributes signiicantly. In Figure 8 (right), t is explained by the noise alone. In
both cases, the normalisation term jCj1=2
is the same, but based on the unit Mahalanobis
covariance ellipses, the noise explanation is more probable. Intuitively, this occurs since it
`wastes' less probability mass in the direction of v1. Of course, in practice there will be N +1 v-vectors all competing with each other and the
noise to explain the data in an N-dimensional space. The general point though still holds: if
we consider increasing the contribution of a given vi , and if the `spread' in C orthogonal to t
is greater than that in the direction of t, then the data can be better explained by increasing
the noise variance 2
, as this increases C identically in all directions (and so increases jCj
less). Thus, at convergence of the 
-optimisation, all the deleted basis functions are those
for which the noise level (whether also optimised or set in advance) can better explain the
data.
A further intuition that may be gleaned from this pictorial perspective is that we might
expect vi that lie more `in the direction of ' t to be more relevant
10 , and so in classiication,
10. Unfortunately, as it would simplify learning if so, the R relevance vectors that are found do not correspond
to the R most closely aligned vi vectors.
23
Sparse Bayesian Learning and the Relevance Vector Machine
Figure 8: Two potential explanations of a data set t. Left: using a basis function in conjunction with noise. Right: using noise alone. Covariance ellipses depicting unit
Mahalanobis distances are shown. For both Gaussians, jCj is the same.
basis functions centred near the decision boundary are unlikely to be retained. Note that
this does not rule out functions located signiicantly on the `wrong' side of the boundary
since vi contributes to C in (34) as an outer product and so can also be relevant if it is well
aligned with t. In fact, an example of such a relevance vector may be seen in Figure 3
(right) earlier.
Finally here, we may glean some understanding of why it may be proitable to optimise
the marginal likelihood with respect to input scale parameters as was outlined in Section
4.3. Figure 9 provides an approximate representation (again pro jected to two dimensions)
of the marginal likelihood model which results from using a Gaussian kernel. For a very
narrow kernel width, it can be seen from (34) that the Gaussian process covariance becomes
diagonal. At the other extreme, a very large width implies that the data set is modelled
only by the (isotropic) noise. It follows that the data set can become more probable at some
intermediate width. While it is not necessarily the case that this is the `optimal' width in
terms of model accuracy, it can at least be seen why the marginal likelihood is not optimised
by inappropriately shrinking the width of the kernel to zero, as would occur if maximising
the conventional likelihood.
Figure 9: E
ect of the width of a Gaussian kernel on the marginal probability of a data
set t. Covariance ellipses depicting lines of equal probability are shown, with the
intermediate Gaussian width (centre) giving the greatest likelihood for t.
23
Tipping
6. Discussion
In this paper we have sought to provide the technical detail and experimental justiication
for a Bayesian approach to sparse learning in linearly-parameterised models, and we have
endeavoured to o
er some understanding of the mechanism through which sparsity is realised. Although we have concentrated on comparison with the popular `support vector
machine', we would underline once more that the presented method is a general one.
We do not seek to state that this approach is deinitively superior to any other; rather
that it is a regression and classiication tool worthy of serious consideration and one which
o
ers some quite compelling and advantageous features, some of which we summarise here:
 Generalisation is typically very good. While it was not the intention to present a
comprehensive comparison with other methods, it was demonstrated in Section 4.4
that results comparable with the state-of-the-art can be obtained.
 `Learned' models are typically highly sparse. Indeed, for the visualisable examples
given in Section 4, the models appear almost optimally compact.
 In classiication, the model gives estimates of the posterior probability of class membership. This is a highly important, but often overlooked, feature of any practical
pattern recognition system.
 There are no `nuisance' parameters to validate, in that the type-II maximum likelihood
procedure automatically sets the `regularisation' parameters, while the noise variance
can be similarly estimated in regression.
 There is no constraint over the number or type of basis functions that may be used, although we note below the computational implications of using a large number thereof.
 We can optimise `global' parameters, such as those which moderate the input variable
scales. This is a very powerful feature, as it is impossible to set such scale parameters
by cross-validation. On a single benchmark task and on isolated problems, we have
found that this can be highly e
ective, though for computational reasons, we cannot
yet present a more extended experimental assessment of the technique.
Another potential advantage of a Bayesian approach is that the fully marginalised probability of a given model (basis set) M, p(tjM) = R p(tj
; 2
;M)p(
)p(2
) d
 d2
, may be
considered a measure of the merit of the model (e.g. could provide a criterion for selection
of the kernel). However, we have already indicated that this quantity cannot be computed
analytically, and the simple and practical numerical approximations that we have employed
have proved ine
ective. In practice, we would use a cross-validation approach, and inding
a criterion (which should require signiicantly less computational overhead) based on an
e
ective approximation to p(tjM) remains an open research question.
We inally note that the primary disadvantage of the sparse Bayesian method is the
computational complexity of the learning algorithm. Although the presented update rules
are very simple in form, their required memory and computation scale respectively with
the square and cube of the number of basis functions. For the RVM, this implies that the
algorithm presented here becomes less practical when the training examples number several
232
Sparse Bayesian Learning and the Relevance Vector Machine
thousand or more. In light of this we have recently developed a much more ecient strategy
for maximising the marginal likelihood, which is discussed brie
y in Appendix B.2, and we
intend to publish further details shortly. Acknowledgments
The author wishes to thank Chris Bishop, Chris Williams, Neil Lawrence, Ralf Herbrich,
Anita Faul, John Platt and Bernhard Scholkopf for helpful discussions, and the latter two
again for the use of their SVM code. In addition, the author was appreciative of many
excellent comments from the reviewers.
Appendix A. Further Details of Relevance Vector Learning
Relevance vector learning involves the maximisation of the product of the marginal likelihood and the priors over 
 and 2
(or i  2
for convenience). Equivalently, and more
straightforwardly, we maximise the log of this quantity. In addition, we also choose to
maximise with respect to log 
 and log i | this is convenient since in practice we assume
uniform hyperpriors over a logarithmic scale, and the derivatives of the prior terms vanish
in this space. So, retaining for now general Gamma priors over 
 and i,we maximise:
log p(tj log 
; log i) +X
N
i=0
log p(log 
i) + log p(log i); (35)
which, ignoring terms independent of 
 and i, and noting that p(log 
) = 
p(
), gives the
ob jective function:
L =
1
2

log ji1I + A1T
j + tT
(i1I + A1T
)1t
 +
X
N
i=0
(a log 
i  b
i) + c log i  di : (36)
Note that the latter terms disappear with a; b; c; d set to zero.
We now consider how to robustly and eciently compute L, outline the derivation of
the hyperparameter updates, and consider the numerical diculties involved.
A.1 Computing the Log Ob jective Function
The matrix i1I + A1T
, which appears in the irst two terms in L, is of size N  N. However, computation of both of the terms of interest may be written as a function of
the posterior weight covariance  = (A + iT)1
. This matrix is M  M, where M is
the number of basis functions in the model. While initially M = N + 1, in practice many
basis functions will be `deleted' during optimisation (see B.1 shortly) and M will decrease
considerably giving signiicant computational advantages as optimisation progresses.
We compute the irst term by exploiting the determinant identity (see, e.g., Mardia
et al., 1979, Appendix A):
jAjji1I + A1T
j = ji1Ijj
Tipping
giving
log ji1I + A1T
j =  log jj  N log i  log jAj: (38)
Using the Woodbury inversion identity:
(i1I + A1T
)1 = iI  i(A + iT)1Ti ;
the second, data-dependent, term may be expressed as
tT
(i1I + A1T
)1t = itT
t  itTTit; = itT
(t  ) ; (40)
with  = iT
t, the posterior weight mean. Note that (40) may be also be re-expressed
as:
itT
(t  ) = ikt  k
2 + itT  iTT; = ikt  k
2 + T1  iTT; = ikt  k
2 + TA; (41)
which corresponds to the penalised log-likelihood evaluated using the posterior mean weights.
The terms in (38) are sometimes referred to as the \Ockham factors".
Computation of , its determinant and  is achieved robustly through Cholesky decomposition of A + iT, an O(M3
) procedure.
A.2 Derivatives and Updates
A.2.1 The hyperparameters
The derivatives of (36) with respect to log 
 are:
@L
@ log 
i =
1
2
1  
i(2
i + ii) + a  b
i: (42)
Setting this to zero and solving for 
i gives a re-estimation rule:

new
i =
1+2a
2
i + ii + 2b
: (43)
This is equivalent to an expectation-maximisation (EM) update (see A.3 below) and so is
guaranteed to locally maximise L. However, setting (42) to zero, and following MacKay
(1992a) in deining quantities 
i  1  
iii, leads to the following update:

new
i =

i + 2a
2
i + 2b
; (44)
which was observed to lead to much faster convergence although it does not beneit from the
guarantee of local maximisation of L. In practice, we did not encounter any optimisation
diculties (i.e. `downhill' st
Sparse Bayesian Learning and the Relevance Vector Machine
A.2.2 The noise variance
Derivatives with respect to log i are:
@L
log i =
1
2 N
i  kt  k
2  tr (T) + c  di ; (45)
and since tr (T) can be re-written as i1 P
i 
i , setting the derivative to zero and
rearranging and re-expressing in terms of 2 gives:
(2
)new =
kt  k2 + 2d
N  P
i 
i + 2c
: (46)
A.3 Expectation-Maximisation (EM) Updates
Another strategy to maximise (36) is to exploit an EM formulation, treating the weights
as the `hidden' variables and maximise Ewjt;
;i [log p(tjw; i)p(wj
)p(
)p(i)], where the
operator Ewjt;
;i [] denotes an expectation with respect to the distribution over the weights
given the data and hidden variables, the posterior p(wjt; 
; i).
For 
, ignoring terms in the logarithm independent thereof, we equivalently maximise:
Ewjt;
;i [log p(wj
)p(
)] ; (47)
which through di
erentiation gives an update:

i =
1+2a
hw2
i i + 2b
; (48)
and where, from the posterior (11), hw2
i i  Ewjt;
;i w2
i  = ii + 2
i . This is therefore
equivalent to the (less ecient) gradient update (43) earlier.
Following the corresponding procedure for the noise level 2 we maximise;
Ewjt;
;i [log p(tjw; i)p(i)] ; (49)
which gives
(2
)new =
kt  k2 + (2
)
old P
i 
i + 2d
N + 2c
: (50)
Appendix B. Computational Considerations
B.1 Numerical Accuracy
The posterior covariance  is computed as the inverse of the `Hessian' matrix H = A +
iT which, although positive deinite in theory, may become numerically singular in
practice. As optimisation of the hyperparameters progresses, the range of 
-values typically
becomes highly extended as many tend towards very large values. Indeed, for a; b; c; d =
0, many 
's typically would tend to ininity if machine precision permitted. In fact, illconditioning of the Hessian matrix becomes a problem when, approximately, the ratio of
the smallest to largest 
-values is in the order of the `machine precisio
Tipping
Consider the case of a single 
i ! 1, where for convenience of presentation we choose
i = 1, the irst hyperparameter. Using the expression for the inverse of a partitioned matrix,
it can be shown that:
 !

0 0
0 (Ai + iTii)1
(51)
where the subscript `i' denotes the matrix with the appropriate i-th row and/or column
removed. The term (Ai + iTii)1
is of course the posterior covariance computed
with basis function i `pruned'. Furthermore, it follows from (51) and (13) that i ! 0 and
as a consequence of 
i ! 1, the model intuitively becomes exactly equivalent to one with
basis function i(x) excluded.
We may thus choose to avoid ill-conditioning by pruning the corresponding basis function from the model at that point (i.e. by deleting the appropriate column from ). This
sparsiication of the model during optimisation implies that we typically experience a very
considerable and advantageous acceleration of the learning algorithm. The potential disadvantage is that if we believed that the marginal likelihood might be increased by reintroducing those deleted basis functions (i.e. reducing 
i from ininity) at a later stage,
then their permanent removal would be suboptimal. For reassurance, at the end of optimisation we can eciently compute the sign of the gradient of the marginal likelihood with
respect to al l 
's corresponding to deleted basis functions. A negative gradient would imply
that reducing an ininite 
, and therefore reintroducing the corresponding basis function,
would improve the likelihood. So far, no such case has been found.
The intuitive and reliable criterion we used for deletion of basis functions and their
weights at each iteration in regression was to remove those whose `well-determinedness'
factors 
i fell below the machine precision ( 2:22  1016 in our case, the smallest 
such that 1 +  6= 1). As a result, presumably, of inaccuracies introduced by the Laplace
approximation step, in classiication a slightly more robust method was required, with
weights deleted for which 
i > 1012
. Note that the action of deleting such a basis function
should not in theory change the value of the ob jective function L (in practice, it should
change only negligibly) since in (38), the ininite part of the terms log jj = log jijlog 
i
and log jAj = log jAij + log 
i cancel.
B.2 Algorithm Complexity
The update rules for the hyperparameters depend on computing the posterior weight covariance matrix, which requires an inverse operation (in fact, Cholesky decomposition) of
order O(M3
) complexity and O(M2
) memory storage, with M the number of basis functions. Although, typically, the pruning discussed above rapidly reduces M to a manageable
size in most problems, M = N + 1 for the RVM model at initialisation, and N may be
very large. This of course leads to extended training times, although the disadvantage of
this is signiicantly o
set by the lack of necessity to perform cross-validation over nuisance
parameters, such as for C and  in the SVM. So, for example, with the exception of the
larger data sets (e.g. roughly N > 700) the benchmark results in Section 4.4 were obtained
more quickly for the RVM (this observation depends on the exact implementations and
cross-validation schedules of 
Sparse Bayesian Learning and the Relevance Vector Machine
Even so, for large data sets, with computation scaling approximately in O(N3
), the full
RVM algorithm becomes prohibitively expensive to run. We have therefore developed an
alternative algorithm to maximise the marginal likelihood which is `constructive'. It starts
with a single basis function, the bias, and both adds in further basis functions, or deletes
current ones, as appropriate, rather than starting with all possible candidates and pruning.
This is a much more ecient approach, as the number of basis functions included at any
step in the algorithm tends to remain low. It is, however, a more `greedy' optimisation
strategy, although our preliminary results show little, if any, loss of accuracy compared to
the standard algorithm. This appears a very promising mechanism for ensuring the sparse
Bayesian approach remains practical even for very large basis function sets.
Appendix C. Adapting Input Scale Parameters
In Section 4.3 we considered how parameters within the kernel speciication could be adapted
to improve the marginal likelihood. We note that in general, we may still prefer to select an
individual kernel parameter (for example, the `width' parameter of a Gaussian ) via crossvalidation. Here, however, we consider the case of multiple input scale parameters, where
cross-validation is not an option and where by optimising such parameters considerable
performance gains may be achieved. The beneit is typically most notable in regression
problems, as exempliied by the Friedman #1 data set benchmark in Section 4.4.1.
Assume that the basis functions take the form
m(x) = m(p
1x1; p
2x2;:::; p
dxd); (52)
where the input vector x comprises d variables (x1;:::;xd) and the corresponding scale
(inverse squared `width') parameters are  = (1;:::;d). We notate nm = m(xn; ) to
be the elements of the design matrix  as before. The gradient of the likelihood L (36)
with respect to the k-th scale parameter is irst written in the form:
@L
@k = X
N
n=1
X
Nm=1
@L
@nm
@nm
@k
: (53)
Note that m = 0 refers to the bias, and so, being independent of x, does not enter into
(53). The irst term in (53) is independent of the basis function parameterisation and it is
convenient to collect all the terms into a matrix D such that Dnm = @L=@nm. Evaluating
these derivatives then gives:
D = (C1ttTC1  C1
)A1
; (54) = i [(t  y)T  ] ; (55)
where C = 2I + A1T
. The form of (55) is intended to be a more intuitive re-writing
of (54).
So for a set of Gaussian basis functions with shared scale parameters:
nm = exp (
X
d
k=1
k(xmk  xnk)
2)
;
Tipping
and we have
@L
@k = X
Nm=1
X
N
n=1 Dnmnm(xmk  xnk)
2
: (57)
The expression (57) can thus be used as the basis for a gradient-based local optimisation
over . Exactly how this is performed represents the primary implementation diculty. A
joint nonlinear optimisation over f
; g, using, for example, conjugate gradient methods,
is prohibitively slow. Since the 
 update equation (44) is so e
ective, we chose to interleave
those updates with a few cycles (e.g. 1 to 5) of optimisation of  using a simple hill-climbing
method. The exact quality of results is somewhat dependent on the ratio of the number
of  to 
 updates, although in nearly all cases a signiicant improvement (in generalisation
error) is observed.
Clearly it would be more satisfactory to o
er a deinitive method for optimising , and we would expect that there is a better mechanism for doing so than the one we have
employed. Nevertheless, the results given for the Friedman #1 task and the `toy' example
of Section 4.3 indicate that, even if simplistically implemented, this is a potentially very
powerful extension to the method.
Appendix D. Probabilistic Outputs
D.1 Error Bars in Regression
Note that, as alluded to earlier, care must be exercised when interpreting the error bars
given by equation (22) since they are predicated on the prior over functions, which in turn
depends on the basis. In the case of the RVM, the basis functions are data-dependent.
To see the implication of this, we re-visit the link with Gaussian process models that was
developed in Section 5.2.
A Gaussian process model is speciied as a (usually zero mean) multivariate Gaussian
distribution over observations, i.e. p(t) = N (tj0; CGP) with
CGP = 2I + Q; (58)
where Qmn = Q(xm; xn) is the covariance function, deined over all x-pairs. There are
no `weights' in the model. Instead, predictions (in terms of predictive distributions) are
obtained from Bayes' rule using p(tjt) = p(t; t)=p(t). The covariance function must
give rise to a positive Q, so like the SVM kernel, must adhere to Mercer's condition.
The `Gaussian' (or negative squared exponential) is a common choice: Q(xm; xn; ) =
1 exp 2kxm  xnk2
. Clearly, the RVM is also a Gaussian process, with C deined as in (34), and indeed we
could also make predictions without recourse to any model `weights'. The corresponding
covariance function, read o
 from (34), for the RVM is:
QRVM(xm; xn) = X
N
i=0

1
i K(xm; xi)K(xn; xi); (59)
where K(x; x0 )=1 denotes the bias. A feature of this prior is that it is data-dependent,
in that the prior covariance between any two points xm and xn depends on all those fxi
Sparse Bayesian Learning and the Relevance Vector Machine
in the training set. This has implications for computing error bars in RVM regression. To
see this, consider that we use a Gaussian covariance function, and compute the predictive
error bars 2
 away from the data, where we would expect them to be signiicant. For the
Gaussian process (Williams, 1999):
2
 = 2 + Q(x; x)  kTCN
GPk;  2 + 1; (60)
where (k)i = K(x; xi), CN
GP is (58) evaluated at the training data points, and we assume
the test point to be suciently distant from the training data such that all K(x; xi), the
elements of k, are very small. Using the identical kernel in a relevance vector model gives
a predictive variance from (22) of:
2
 = 2 + kTk;  2
; (61)
and thus depends only on the noise variance. There is no contribution from the function
prior which may seem odd, but is of course consistent with its speciication.
D.2 Posterior Probabilities in Classiication
When performing `classiication' of some test example x, we would prefer our model to
give an estimate of p(t 2 Cjx), the posterior probability of the example's membership of
the class C given the features x. This quantity expresses the uncertainty in the prediction
in a principled manner while facilitating the separation of `inference' and `decision' (Duda
and Hart, 1973). In practical terms, these posterior probability estimates are necessary
to correctly adapt to asymmetric misclassiication costs (which nearly always apply in real
applications) and varying class proportions, as well as allowing the rejection of `uncertain'
test examples if desired.
Importantly, the presented Bayesian classiication formulation incorporates the Bernoulli
output distribution (equivalent in the log-domain to the `cross-entropy' error function),
which in conjunction with the logistic sigmoid squashing function, enables fy(x)g to be
interpreted as a consistent estimate of the posterior probability of class membership. Provided y(x) is suciently 
exible, in the ininite data limit this estimate becomes exact (see,
e.g., Bishop, 1995).
By contrast, for a test point x the SVM outputs a real number which is thresholded to
give a `hard' binary decision as to the class of the target t. The absence of posterior probabilities from the SVM is an acknowledged deiciency, and a recently proposed technique for
tackling this involves the a posteriori itting of a sigmoid function to the ixed SVM output
y(x) (Platt, 2000) to give an approximate probability of the form fA:y(x) + Bg. While
this approach does at least produce predictive outputs in the range [0; 1], it is important
to realise that this does not imply that the output of the sigmoid is necessarily a good
approximation of the posterior probability. The success of this post-processing strategy is
predicated on the original output y(x) of the SVM, with appropriate shifting and rescaling,
being a good approximation to the `inverse-sigmoid' of the desired posterior probability. This is the quantity logfp(t 2 C+1jx)=p(t 2 C1jx)g, referred to as the `log-odds'. As a
2
Tipping
result of the nature of the SVM ob jective function, y(x) cannot be expected to be a reliable
model of this.
The simple example which follows in Figure 10 underlines this. The igure shows the
output of trained classiiers on a simple two-class problem in one dimension. Class C+1 is
uniform in [0; 1] and class C1 in [0:5; 1:5], with the overlap implying a minimal Bayes error
of 25%. The correct log-odds of C+1 over C1 is shown in the igure. It should be zero
in [0:5; 1:5] and ininite outside this region. The output y(x) of both SVM and RVM (i.e.
without the sigmoid function in the latter case) is shown for classiiers trained on a generous
quantity of examples (1000) using a Gaussian kernel of width 0.1. Note that both models
are optimal in the generalisation sense, since the decision boundary may lie anywhere in
[0:5; 1].
0.4 0.6 0.8 1 1.2
-6
-4
-2
0
2
4
6 Correct log-odds
RVM y(x)
SVM y(x)
Figure 10: Output of an RVM and SVM trained on overlapping, uniformly distributed data,
along with the true log-odds of membership of C+1 over C1. The SVM output
has been rescaled without prejudice for ease of comparison with the RVM.
The key feature of Figure 10 is that while the RVM o
ers a reasonable approximation,
the SVM output is highly unrepresentative of the true log-odds. It should be evident that
no setting of the sigmoid parameters A and B can ever correct for this. This is exempliied
in the region x 2 [0:5; 1], in the vicinity of the decision boundary where posterior accuracy is
arguably most important, and where the log-odds should be constant. Practically, we note
that if this were a real application with asymmetric misclassiication losses, for example
medical diagnosis or insurance risk assessment, then the absence of, or lack of accuracy in,
posterior estimates could be very costly.

Sparse Bayesian Learning and the Relevance Vector Machine
Appendix E. Benchmark Data Sets
E.1 Regression
Noisy sinc. Data was generated from the function y(x) = sin(x)=x at 100 equally-spaced
x-values in [10; 10] with added noise from two distributions: irst, Gaussian of standard
deviation 0.1 and second, uniform in [0:1; 0:1]. In both cases, results were averaged over
100 random instantiations of the noise, with the error being measured to the true function
over a 1000-example test set of equally spaced samples in [10; 10].
Friedman functions. Synthetic functions taken from Friedman (1991):
y#1(x) = 10 sin(x1x2) + 20(x3  1=2)2 + 10x4 + 5x5 +X
10
k=6
0:xk; (62)
y#2(x)=[x2
1 + (x2x3  1=x2x4)
2
]1=2
; (63)
y#3(x) = tan1  x2x3  1=x2x4
x1 
: (64)
For #1, inputs were generated at random from the 10-dimensional unit hypercube (note that
input variables x6 through x10 do not contribute to the function) and Gaussian noise of unit
standard deviation added to y(x). For #2 and #3, random input samples were generated
uniformly in the intervals x1 2 [0; 100], x2 2 [40; 560], x3 2 [0; 1] and x4 2 [1; 11].
Additive Gaussian noise was generated on the output of standard deviation one-third of
that of the signal y(x). For all Friedman functions, average results for 100 repetitions were
quoted, where 240 randomly generated training examples were utilised, along with 1000
noise-free test examples.
Boston housing. This popular regression benchmark data set was obtained from the
StatLib archive at http://lib.stat.cmu.edu/datasets/boston. It comprises 506 examples with 14 variables, and results were given for the task of predicting the median house
value from the remaining 13 variables. Averages were given over 100 repetitions, where 481
randomly chosen examples were used for training and the remaining 25 used for testing.
E.2 Classiication
Pima Diabetes. This data was utilised as an example set by Ripley (1996), and re-used
by Williams and Barber (1998). We used the single split of the data into 200 training and
332 test examples available at http://www.stats.ox.ac.uk/pub/PRNN/. U.S.P.S. The U.S. Postal Service database of 1616 images of digits `0' through `9' is that
commonly utilised as a benchmark for SVM-related techniques, e.g. as used by Scholkopf
et al. (1999b). The data utilised here was obtained from those authors, and comprises 7291
training examples along with a 2007-example test set.
Banana, Breast Cancer, Titanic, Waveform, German, Image. All these data sets
were taken from the collection recently utilised by Ratsch et al. (2001). More details concerning the original provenance of the sets are available in a highly comprehensive online
repository at http://ida.first.gmd.de/raetsch/. A total of 100 training/test splits
are provided by those authors: our results show averages over the irst 10 of thos
Tipping
