Machine Learning in Automated Text Categorization
Fabrizio Sebastiani
Consiglio Nazionale delle Ricerche, Italy
The automated categorization (or classification) of texts into predefined categories has witnessed a
booming interest in the last ten years, due to the increased availability of documents in digital form
and the ensuing need to organize them. In the research community the dominant approach to this
problem is based on machine learning techniques: a general inductive process automatically builds
a classifier by learning, from a set of preclassified documents, the characteristics of the categories.
The advantages of this approach over the knowledge engineering approach (consisting in the
manual definition of a classifier by domain experts) are a very good effectiveness, considerable
savings in terms of expert manpower, and straightforward portability to different domains. This
survey discusses the main approaches to text categorization that fall within the machine learning
paradigm. We will discuss in detail issues pertaining to three different problems, namely document
representation, classifier construction, and classifier evaluation.
Categories and Subject Descriptors: H.3.1 [Information storage and retrieval]: Content analysis and indexing—Indexing methods; H.3.3 [Information storage and retrieval]: Information search and retrieval—Information filtering; H.3.3 [Information storage and retrieval]:
Systems and software—Performance evaluation (efficiency and effectiveness); I.2.3 [Artificial
Intelligence]: Learning—Induction
General Terms: Algorithms, Experimentation, Theory
Additional Key Words and Phrases: Machine learning, text categorization, text classification
1. INTRODUCTION
In the last ten years content-based document management tasks (collectively known
as information retrieval – IR) have gained a prominent status in the information
systems field, due to the increased availability of documents in digital form and
the ensuing need to access them in flexible ways. Text categorization (TC – aka
text classification, or topic spotting), the activity of labelling natural language texts
with thematic categories from a predefined set, is one such task. TC dates back
to the early ’60s, but only in the early ’90s it became a major subfield of the
information systems discipline, thanks to increased applicative interest and to the
availability of more powerful hardware. TC is now being applied in many contexts,
ranging from document indexing based on a controlled vocabulary, to document
filtering, automated metadata generation, word sense disambiguation, population
of hierarchical catalogues of Web resources, and in general any application requiring
document organization or selective and adaptive document dispatching.
Until the late ’80s the most popular approach to TC, at least in the “operational” (i.e. real-world applications) community, was a knowledge engineering (KE)
one, consisting in manually defining a set of rules encoding expert knowledge on
Address: Istituto di Elaborazione dell’Informazione, Consiglio Nazionale delle Ricerche, Via G.
Moruzzi, 1, 56124 Pisa (Italy). E-mail: fabrizio@iei.pi.cnr.it
2 · F. Sebastiani
how to classify documents under the given categories. In the ’90s this approach has
increasingly lost popularity (especially in the research community) in favour of the
machine learning (ML) paradigm, according to which a general inductive process
automatically builds an automatic text classifier by learning, from a set of preclassified documents, the characteristics of the categories of interest. The advantages
of this approach are an accuracy comparable to that achieved by human experts,
and a considerable savings in terms of expert manpower, since no intervention from
either knowledge engineers or domain experts is needed for the construction of the
classifier or for its porting to a different set of categories. It is the ML approach to
TC that this paper concentrates on.
Current-day TC is thus a discipline at the crossroads of ML and IR, and as such it
shares a number of characteristics with other tasks such as information/knowledge
extraction from texts and text mining [Knight 1999; Pazienza 1997]. There is still
considerable debate on where the exact border between these disciplines lies, and the
terminology is still evolving. “Text mining” is increasingly being used to denote all
the tasks that, by analyzing large quantities of text and detecting usage patterns, try
to extract probably useful (although only probably correct) information. According
to this view, TC is an instance of text mining. TC enjoys quite a rich literature now,
but this is still fairly scattered1
. Although two international journals have devoted
special issues to this topic [Joachims and Sebastiani 2001; Lewis and Hayes 1994],
there are no systematic treatments of the subject: there are neither textbooks nor
journals entirely devoted to TC yet, and [Manning and Sch¨utze 1999, Chapter16]
is the only chapter-length treatment of the subject. As a note, we should warn the
reader that the term “automatic text classification” has sometimes been used in
the literature to mean things quite different from the ones discussed here. Aside
from (i) the automatic assignment of documents to a predefined set of categories,
which is the main topic of this paper, the term has also been used to mean (ii) the
automatic identification of such a set of categories (e.g. [Borko and Bernick 1963]),
or (iii) the automatic identification of such a set of categories and the grouping of
documents under them (e.g. [Merkl 1998]), a task usually called text clustering, or
(iv) any activity of placing text items into groups, a task that has thus both TC
and text clustering as particular instances [Manning and Sch¨utze 1999].
This paper is organized as follows. In Section 2 we formally define TC and its
various subcases, and in Section 3 we review its most important applications. Section 4 describes the main ideas underlying the ML approach to classification. Our
discussion of text classification starts in Section 5 by introducing text indexing, i.e.
the transformation of textual documents into a form that can be interpreted by a
classifier-building algorithm and by the classifier eventually built by it. Section 6
tackles the inductive construction of a text classifier from a “training” set of preclassified documents. Section 7 discusses the evaluation of text classifiers. Section
8 concludes, discussing open issues and possible avenues of further research for TC.
2. TEXT CATEGORIZATION
1A fully searchable bibliography on TC created and maintained by this author is available at
http://liinwww.ira.uka.de/bibliography/Ai/automated.text.categorization.html
Machine Learning in Automated Text Categorization · 3
2.1 A definition of text categorization
Text categorization is the task of assigning a Boolean value to each pair hdj , cii ?
D×C, where D is a domain of documents and C = {c1, . . . , c|C|} is a set of predefined
categories. A value of T assigned to hdj , cii indicates a decision to file dj under ci
,
while a value of F indicates a decision not to file dj under ci
. More formally, the task
is to approximate the unknown target function F : ? D × C ? {T, F} (that describes
how documents ought to be classified) by means of a function F : D × C ? {T, F}
called the classifier (aka rule, or hypothesis, or model) such that F and F “coincide ?
as much as possible”. How to precisely define and measure this coincidence (called
effectiveness) will be discussed in Section 7.1. From now on we will assume that:
—The categories are just symbolic labels, and no additional knowledge (of a procedural or declarative nature) of their meaning is available.
—No exogenous knowledge (i.e. data provided for classification purposes by an external source) is available; therefore, classification must be accomplished on the
basis of endogenous knowledge only (i.e. knowledge extracted from the documents). In particular, this means that metadata such as e.g. publication date,
document type, publication source, etc. is not assumed to be available.
The TC methods we will discuss are thus completely general, and do not depend on
the availability of special-purpose resources that might be unavailable or costly to
develop. Of course, these assumptions need not be verified in operational settings,
where it is legitimate to use any source of information that might be available or
deemed worth developing [D´iaz Esteban et al. 1998; Junker and Abecker 1997].
Relying only on endogenous knowledge means classifying a document based solely
on its semantics, and given that the semantics of a document is a subjective notion,
it follows that the membership of a document in a category (pretty much as the
relevance of a document to an information need in IR [Saracevic 1975]) cannot be
decided deterministically. This is exemplified by the phenomenon of inter-indexer
inconsistency [Cleverdon 1984]: when two human experts decide whether to classify
document dj under category ci
, they may disagree, and this in fact happens with
relatively high frequency. A news article on Clinton attending Dizzy Gillespie’s
funeral could be filed under Politics, or under Jazz, or under both, or even under
neither, depending on the subjective judgment of the expert.
2.2 Single-label vs. multi-label text categorization
Different constraints may be enforced on the TC task, depending on the application.
For instance we might need that, for a given integer k, exactly k (or = k, or = k)
elements of C be assigned to each dj ? D. The case in which exactly 1 category
must be assigned to each dj ? D is often called the single-label (aka non-overlapping
categories) case, while the case in which any number of categories from 0 to |C|
may be assigned to the same dj ? D is dubbed the multi-label (aka overlapping
categories) case. A special case of single-label TC is binary TC, in which each
dj ? D must be assigned either to category ci or to its complement ci
.
From a theoretical point of view, the binary case (hence, the single-label case too)
is more general than the multi-label, since an algorithm for binary classification can
also be used for multi-label classification: one needs only transform the problem
4 · F. Sebastiani
of multi-label classification under {c1, . . . , c|C|} into |C| independent problems of
binary classification under {ci
, ci}, for i = 1, . . . , |C|. However, this requires that
categories are stochastically independent of each other, i.e. that for any c
'
, c'' the
value of F( ? dj , c'
) does not depend on the value of F( ? dj , c'') and viceversa; this
is usually assumed to be the case (applications in which this is not the case are
discussed in Section 3.5). The converse is not true: an algorithm for multi-label
classification cannot be used for either binary or single-label classification. In fact,
given a document dj to classify, (i) the classifier might attribute k > 1 categories to
dj , and it might not be obvious how to choose a “most appropriate” category from
them; or (ii) the classifier might attribute to dj no category at all, and it might not
be obvious how to choose a “least inappropriate” category from C.
In the rest of the paper, unless explicitly mentioned, we will deal with the binary
case. There are various reasons for this:
—The binary case is important in itself because important TC applications, including filtering (see Section 3.3), consist of binary classification problems (e.g.
deciding whether dj is about Jazz or not). In TC, most binary classification problems feature unevenly populated categories (e.g. much fewer documents are about
Jazz than are not) and unevenly characterized categories (e.g. what is about Jazz
can be characterized much better than what is not).
—Solving the binary case also means solving the multi-label case, which is also
representative of important TC applications, including automated indexing for
Boolean systems (see Section 3.1).
—Most of the TC literature is couched in terms of the binary case.
—Most techniques for binary classification are just special cases of existing techniques for the single-label case, and are simpler to illustrate than these latter.
This ultimately means that we will view classification under C = {c1, . . . , c|C|} as
consisting of |C| independent problems of classifying the documents in D under a
given category ci
, for i = 1, . . . , |C|. A classifier for ci
is then a function Fi
: D ?
{T, F} that approximates an unknown target function F?
i
: D ? {T, F}.
2.3 Category-pivoted vs. document-pivoted text categorization
There are two different ways of using a text classifier. Given dj ? D, we might want
to find all the ci ? C under which it should be filed (document-pivoted categorization
– DPC); alternatively, given ci ? C, we might want to find all the dj ? D that should
be filed under it (category-pivoted categorization – CPC). This distinction is more
pragmatic than conceptual, but is important since the sets C and D might not be
available in their entirety right from the start. It is also relevant to the choice of
the classifier-building method, as some of these methods (see e.g. Section 6.9) allow
the construction of classifiers with a definite slant towards one or the other style.
DPC is thus suitable when documents become available at different moments in
time, e.g. in filtering e-mail. CPC is instead suitable when (i) a new category c|C|+1
may be added to an existing set C = {c1, . . . , c|C|} after a number of documents have
already been classified under C, and (ii) these documents need to be reconsidered
for classification under c|C|+1 (e.g. [Larkey 1999]). DPC is used more often than
CPC, as the former situation is more common than the latter.
Machine Learning in Automated Text Categorization · 5
Although some specific techniques apply to one style and not to the other (e.g. the
proportional thresholding method discussed in Section 6.1 applies only to CPC),
this is more the exception than the rule: most of the techniques we will discuss
allow the construction of classifiers capable of working in either mode.
2.4 “Hard” categorization vs. ranking categorization
While a complete automation of the TC task requires a T or F decision for each
pair hdj , cii, a partial automation of this process might have different requirements.
For instance, given dj ? D a system might simply rank the categories in C =
{c1, . . . , c|C|} according to their estimated appropriateness to dj , without taking
any “hard” decision on any of them. Such a ranked list would be of great help to a
human expert in charge of taking the final categorization decision, since she could
thus restrict the choice to the category (or categories) at the top of the list, rather
than having to examine the entire set. Alternatively, given ci ? C a system might
simply rank the documents in D according to their estimated appropriateness to ci
;
symmetrically, for classification under ci a human expert would just examine the
top-ranked documents instead than the entire document set. These two modalities
are sometimes called category-ranking TC and document-ranking TC [Yang 1999],
respectively, and are the obvious counterparts of DPC and CPC.
Semi-automated, “interactive” classification systems [Larkey and Croft 1996] are
useful especially in critical applications in which the effectiveness of a fully automated system may be expected to be significantly lower than that of a human
expert. This may be the case when the quality of the training data (see Section
4) is low, or when the training documents cannot be trusted to be a representative
sample of the unseen documents that are to come, so that the results of a completely
automatic classifier could not be trusted completely.
In the rest of the paper, unless explicitly mentioned, we will deal with “hard”
classification; however, many of the algorithms we will discuss naturally lend themselves to ranking TC too (more details on this in Section 6.1).
3. APPLICATIONS OF TEXT CATEGORIZATION
TC goes back to Maron’s [1961] seminal work on probabilistic text classification.
Since then, it has been used for a number of different applications, of which we here
briefly review the most important ones. Note that the borders between the different
classes of applications listed here are fuzzy and somehow artificial, and some of these
may be considered special cases of others. Other applications we do not explicitly
discuss are speech categorization by means of a combination of speech recognition
and TC [Myers et al. 2000; Schapire and Singer 2000], multimedia document categorization through the analysis of textual captions [Sable and Hatzivassiloglou 2000],
author identification for literary texts of unknown or disputed authorship [Forsyth
1999], language identification for texts of unknown language [Cavnar and Trenkle
1994], automated identification of text genre [Kessler et al. 1997], and automated
essay grading [Larkey 1998].
3.1 Automatic indexing for Boolean information retrieval systems
The application that has spawned most of the early research in the field [Borko and
Bernick 1963; Field 1975; Gray and Harley 1971; Heaps 1973; Maron 1961], is that
6 · F. Sebastiani
of automatic document indexing for IR systems relying on a controlled dictionary,
the most prominent example of which is that of Boolean systems. In these latter
each document is assigned one or more keywords or keyphrases describing its content, where these keywords and keyphrases belong to a finite set called controlled
dictionary, often consisting of a thematic hierarchical thesaurus (e.g. the NASA thesaurus for the aerospace discipline, or the MESH thesaurus for medicine). Usually,
this assignment is done by trained human indexers, and is thus a costly activity.
If the entries in the controlled vocabulary are viewed as categories, text indexing
is an instance of TC, and may thus be addressed by the automatic techniques described in this paper. Recalling Section 2.2, note that this application may typically
require that k1 = x = k2 keywords are assigned to each document, for given k1, k2.
Document-pivoted TC is probably the best option, so that new documents may be
classified as they become available. Various text classifiers explicitly conceived for
document indexing have been described in the literature; see e.g. [Fuhr and Knorz
1984; Robertson and Harding 1984; Tzeras and Hartmann 1993].
Automatic indexing with controlled dictionaries is closely related to automated
metadata generation. In digital libraries one is usually interested in tagging documents by metadata that describe them under a variety of aspects (e.g. creation
date, document type or format, availability, etc.). Some of these metadata are
thematic, i.e. their role is to describe the semantics of the document by means of
bibliographic codes, keywords or keyphrases. The generation of these metadata
may thus be viewed as a problem of document indexing with controlled dictionary,
and thus tackled by means of TC techniques.
3.2 Document organization
Indexing with a controlled vocabulary is an instance of the general problem of document base organization. In general, many other issues pertaining to document
organization and filing, be it for purposes of personal organization or structuring of
a corporate document base, may be addressed by TC techniques. For instance, at
the offices of a newspaper incoming “classified” ads must be, prior to publication,
categorized under categories such as Personals, Cars for Sale, Real Estate,
etc. Newspapers dealing with a high volume of classified ads would benefit from
an automatic system that chooses the most suitable category for a given ad. Other
possible applications are the organization of patents into categories for making their
search easier [Larkey 1999], the automatic filing of newspaper articles under the appropriate sections (e.g. Politics, Home News, Lifestyles, etc.), or the automatic
grouping of conference papers into sessions.
3.3 Text filtering
Text filtering is the activity of classifying a stream of incoming documents dispatched in an asynchronous way by an information producer to an information
consumer [Belkin and Croft 1992]. A typical case is a newsfeed, where the producer is a news agency and the consumer is a newspaper [Hayes et al. 1990]. In
this case the filtering system should block the delivery of the documents the consumer is likely not interested in (e.g. all news not concerning sports, in the case
of a sports newspaper). Filtering can be seen as a case of single-label TC, i.e. the
classification of incoming documents in two disjoint categories, the relevant and the
Machine Learning in Automated Text Categorization · 7
irrelevant. Additionally, a filtering system may also further classify the documents
deemed relevant to the consumer into thematic categories; in the example above,
all articles about sports should be further classified according e.g. to which sport
they deal with, so as to allow journalists specialized in individual sports to access
only documents of prospective interest for them. Similarly, an e-mail filter might
be trained to discard “junk” mail [Androutsopoulos et al. 2000; Drucker et al. 1999]
and further classify non-junk mail into topical categories of interest to the user.
A filtering system may be installed at the producer end, in which case it must
route the documents to the interested consumers only, or at the consumer end, in
which case it must block the delivery of documents deemed uninteresting to the
consumer. In the former case the system builds and updates a “profile” for each
consumer [Liddy et al. 1994], while in the latter case (which is the more common,
and to which we will refer in the rest of this section) a single profile is needed.
A profile may be initially specified by the user, thereby resembling a standing
IR query, and is updated by the system by using feedback information provided
(either implicitly or explicitly) by the user on the relevance or non-relevance of the
delivered messages. In the TREC community [Lewis 1995c] this is called adaptive
filtering, while the case in which no user-specified profile is available is called either
routing or batch filtering, depending on whether documents have to be ranked in
decreasing order of estimated relevance or just accepted/rejected. Batch filtering
thus coincides with single-label TC under |C| = 2 categories; since this latter is
a completely general TC task some authors [Hull 1994; Hull et al. 1996; Schapire
et al. 1998; Sch¨utze et al. 1995], somewhat confusingly, use the term “filtering” in
place of the more appropriate term “categorization”.
In information science document filtering has a tradition dating back to the
’60s, when, addressed by systems of various degrees of automation and dealing
with the multi-consumer case discussed above, it was called selective dissemination
of information or current awareness (see e.g. [Korfhage 1997, Chapter 6]). The
explosion in the availability of digital information has boosted the importance of
such systems, which are nowadays being used in contexts such as the creation of
personalized Web newspapers, junk e-mail blocking, and Usenet news selection.
Information filtering by ML techniques is widely discussed in the literature: see
e.g. [Amati and Crestani 1999; Iyer et al. 2000; Kim et al. 2000; Tauritz et al. 2000;
Yu and Lam 1998].
3.4 Word sense disambiguation
Word sense disambiguation (WSD) is the activity of finding, given the occurrence
in a text of an ambiguous (i.e. polysemous or homonymous) word, the sense of this
particular word occurrence. For instance, bank may have (at least) two different
senses in English, as in the Bank of England (a financial institution) or the bank
of river Thames (a hydraulic engineering artifact). It is thus a WSD task to
decide which of the above senses the occurrence of bank in Last week I borrowed
some money from the bank has. WSD is very important for many applications,
including natural language processing, and indexing documents by word senses
rather than by words for IR purposes. WSD may be seen as a TC task (see e.g
[Gale et al. 1993; Escudero et al. 2000]) once we view word occurrence contexts as
documents and word senses as categories. Quite obviously, this is a single-label TC
8 · F. Sebastiani
case, and one in which document-pivoted TC is usually the right choice.
WSD is just an example of the more general issue of resolving natural language ambiguities, one of the most important problems in computational linguistics. Other examples, which may all be tackled by means of TC techniques along
the lines discussed for WSD, are context-sensitive spelling correction, prepositional
phrase attachment, part of speech tagging, and word choice selection in machine
translation; see [Roth 1998] for an introduction.
3.5 Hierarchical categorization of Web pages
TC has recently aroused a lot of interest also for its possible application to automatically classifying Web pages, or sites, under the hierarchical catalogues hosted
by popular Internet portals. When Web documents are catalogued in this way,
rather than issuing a query to a general-purpose Web search engine a searcher may
find it easier to first navigate in the hierarchy of categories and then restrict her
search to a particular category of interest.
Classifying Web pages automatically has obvious advantages, since the manual
categorization of a large enough subset of the Web is infeasible. Unlike in the
previous applications, it is typically the case that each category must be populated
by a set of k1 = x = k2 documents. CPC should be chosen so as to allow new
categories to be added and obsolete ones to be deleted.
With respect to previously discussed TC applications, automatic Web page categorization has two essential peculiarities:
(1) The hypertextual nature of the documents: links are a rich source of information,
as they may be understood as stating the relevance of the linked page to the
linking page. Techniques exploiting this intuition in a TC context have been
presented in [Attardi et al. 1998; Chakrabarti et al. 1998b; F¨urnkranz 1999;
G¨overt et al. 1999; Oh et al. 2000] and experimentally compared in [Yang et al.
2001].
(2) The hierarchical structure of the category set: this may be used e.g. by decomposing the classification problem into a number of smaller classification
problems, each corresponding to a branching decision at an internal node.
Techniques exploiting this intuition in a TC context have been presented in
[Dumais and Chen 2000; Chakrabarti et al. 1998a; Koller and Sahami 1997;
McCallum et al. 1998; Ruiz and Srinivasan 1999; Weigend et al. 1999].
4. THE MACHINE LEARNING APPROACH TO TEXT CATEGORIZATION
In the ’80s the most popular approach (at least in operational settings) for the
creation of automatic document classifiers consisted in manually building, by means
of knowledge engineering (KE) techniques, an expert system capable of taking TC
decisions. Such an expert system would typically consist of a set of manually defined
logical rules, one per category, of type
if hDNF formulai then hcategoryi
A DNF (“disjunctive normal form”) formula is a disjunction of conjunctive clauses;
the document is classified under hcategoryi iff it satisfies the formula, i.e. iff it
satisfies at least one of the clauses. The most famous example of this approach is
Machine Learning in Automated Text Categorization · 9
if ((wheat & farm) or
(wheat & commodity) or
(bushels & export) or
(wheat & tonnes) or
(wheat & winter & ¬ soft)) then Wheat else ¬ Wheat
Fig. 1. Rule-based classifier for the Wheat category; keywords are indicated in italic, categories
are indicated in Small Caps (from [Apt´e et al. 1994]).
the Construe system [Hayes et al. 1990], built by Carnegie Group for the Reuters
news agency. A sample rule of the type used in Construe is illustrated in Figure
1.
The drawback of this approach is the knowledge acquisition bottleneck well-known
from the expert systems literature. That is, the rules must be manually defined by
a knowledge engineer with the aid of a domain expert (in this case, an expert in the
membership of documents in the chosen set of categories): if the set of categories
is updated, then these two professionals must intervene again, and if the classifier
is ported to a completely different domain (i.e. set of categories) a different domain
expert needs to intervene and the work has to be repeated from scratch.
On the other hand, it was originally suggested that this approach can give very
good effectiveness results: Hayes et al. [1990] reported a .90 “breakeven” result
(see Section 7) on a subset of the Reuters test collection, a figure that outperforms
even the best classifiers built in the late ’90s by state-of-the-art ML techniques.
However, no other classifier has been tested on the same dataset as Construe,
and it is not clear whether this was a randomly chosen or a favourable subset of
the entire Reuters collection. As argued in [Yang 1999], the results above do not
allow us to state that these effectiveness results may be obtained in general.
Since the early ’90s, the ML approach to TC has gained popularity and has eventually become the dominant one, at least in the research community (see [Mitchell
1996] for a comprehensive introduction to ML). In this approach a general inductive process (also called the learner ) automatically builds a classifier for a category
ci by observing the characteristics of a set of documents manually classified under ci or ci by a domain expert; from these characteristics, the inductive process
gleans the characteristics that a new unseen document should have in order to be
classified under ci
. In ML terminology, the classification problem is an activity of
supervised learning, since the learning process is “supervised” by the knowledge of
the categories and of the training instances that belong to them2
.
The advantages of the ML approach over the KE approach are evident. The
engineering effort goes towards the construction not of a classifier, but of an automatic builder of classifiers (the learner ). This means that if a learner is (as it often
is) available off-the-shelf, all that is needed is the inductive, automatic construction
of a classifier from a set of manually classified documents. The same happens if
a classifier already exists and the original set of categories is updated, or if the
classifier is ported to a completely different domain.
2Within the area of content-based document management tasks, an example of an unsupervised
learning activity is document clustering (see Section 1).
10 · F. Sebastiani
In the ML approach the preclassified documents are then the key resource. In the
most favourable case they are already available; this typicaly happens for organizations which have previously carried out the same categorization activity manually
and decide to automate the process. The less favourable case is when no manually
classified documents are available; this typicaly happens for organizations which
start a categorization activity and opt for an automated modality straightaway.
The ML approach is more convenient than the KE approach also in this latter
case. In fact, it is easier to manually classify a set of documents than to build and
tune a set of rules, since it is easier to characterize a concept extensionally (i.e. to
select instances of it) than intensionally (i.e. to describe the concept in words, or
to describe a procedure for recognizing its instances).
Classifiers built by means of ML techniques nowadays achieve impressive levels
of effectiveness (see Section 7), making automatic classification a qualitatively (and
not only economically) viable alternative to manual classification.
4.1 Training set, test set, and validation set
The ML approach relies on the availability of an initial corpus ? = {d1, . . . , d|?|} ?
D of documents preclassified under C = {c1, . . . , c|C|}. That is, the values of the
total function F : ? D × C ? {T, F} are known for every pair hdj , cii ? ? × C. A
document dj is a positive example of ci
if F( ? dj , ci) = T , a negative example of ci
if
F( ? dj , ci) = F.
In research settings (and in most operational settings too), once a classifier F has
been built it is desirable to evaluate its effectiveness. In this case, prior to classifier
construction the initial corpus is split in two sets, not necessarily of equal size:
—a training(-and-validation) set T V = {d1, . . . , d|T V |}. The classifier F for categories C = {c1, . . . , c|C|} is inductively built by observing the characteristics of
these documents;
—a test set T e = {d|T V |+1, . . . , d|?|}, used for testing the effectiveness of the classifiers. Each dj ? T e is fed to the classifier, and the classifier decisions F(dj , ci)
are compared with the expert decisions F( ? dj , ci). A measure of classification effectiveness is based on how often the F(dj , ci) values match the F( ? dj , ci) values.
The documents in T e cannot participate in any way in the inductive construction of
the classifiers; if this condition were not satisfied the experimental results obtained
would likely be unrealistically good, and the evaluation would thus have no scientific
character [Mitchell 1996, page 129]. In an operational setting, after evaluation has
been performed one would typically re-train the classifier on the entire initial corpus,
in order to boost effectiveness. In this case the results of the previous evaluation
would be a pessimistic estimate of the real performance, since the final classifier
has been trained on more data than the classifier evaluated.
This is called the train-and-test approach. An alternative is the k-fold crossvalidation approach (see e.g. [Mitchell 1996, page 146]), in which k different classifiers F1, . . . , Fk are built by partitioning the initial corpus into k disjoint sets
T e1, . . . , T ek and then iteratively applying the train-and-test approach on pairs
hT Vi = ? - T ei
, T eii. The final effectiveness figure is obtained by individually
computing the effectiveness of F1, . . . , Fk, and then averaging the individual re-
Machine Learning in Automated Text Categorization · 11
sults in some way.
In both approaches it is often the case that the internal parameters of the classifiers must be tuned, by testing which values of the parameters yield the best effectiveness. In order to make this optimization possible, in the train-and-test approach
the set {d1, . . . , d|T V |} is further split into a training set T r = {d1, . . . , d|T r|}, from
which the classifier is built, and a validation set V a = {d|T r|+1, . . . , d|T V |} (sometimes called a hold-out set), on which the repeated tests of the classifier aimed
at parameter optimization are performed; the obvious variant may be used in the
k-fold cross-validation case. Note that, for the same reason why we do not test a
classifier on the documents it has been trained on, we do not test it on the documents it has been optimized on: test set and validation set must be kept separate3
.
Given a corpus ?, one may define the generality g?(ci) of a category ci as the
percentage of documents that belong to ci
, i.e.:
g?(ci) = |{dj ? ? | F( ? dj , ci) = T }|
|?|
The training set generality gT r(ci), validation set generality gV a(ci), and test set
generality gT e(ci) of ci may be defined in the obvious way.
4.2 Information retrieval techniques and text categorization
Text categorization heavily relies on the basic machinery of IR. The reason is that
TC is a content-based document management task, and as such it shares many
characteristics with other IR tasks such as text search.
IR techniques are used in three phases of the text classifier life cycle:
(1) IR-style indexing is always performed on the documents of the initial corpus
and on those to be classified during the operational phase;
(2) IR-style techniques (such as document-request matching, query reformulation,
. . . ) are often used in the inductive construction of the classifiers;
(3) IR-style evaluation of the effectiveness of the classifiers is performed.
The various approaches to classification differ mostly for how they tackle (2), although in a few cases non-standard approaches to (1) and (3) are also used. Indexing, induction and evaluation are the themes of Sections 5, 6 and 7, respectively.
5. DOCUMENT INDEXING AND DIMENSIONALITY REDUCTION
5.1 Document indexing
Texts cannot be directly interpreted by a classifier or by a classifier-building algorithm. Because of this, an indexing procedure that maps a text dj into a compact
representation of its content needs to be uniformly applied to training, validation
and test documents. The choice of a representation for text depends on what one
regards as the meaningful units of text (the problem of lexical semantics) and the
meaningful natural language rules for the combination of these units (the problem
3From now on, we will take the freedom to use the expression “test document” to denote any
document not in the training set and validation set. This includes thus any document submitted
to the classifier in the operational phase.
12 · F. Sebastiani
of compositional semantics). Similarly to what happens in IR, in TC this latter
problem is usually disregarded4
, and a text dj is usually represented as a vector of
term weights ~dj = hw1j , . . . , w|T |ji, where T is the set of terms (sometimes called
features) that occur at least once in at least one document of T r, and 0 = wkj = 1
represents, loosely speaking, how much term tk contributes to the semantics of
document dj . Differences among approaches are accounted for by
(1) different ways to understand what a term is;
(2) different ways to compute term weights.
A typical choice for (1) is to identify terms with words. This is often called either the
set of words or the bag of words approach to document representation, depending
on whether weights are binary or not.
In a number of experiments [Apt´e et al. 1994; Dumais et al. 1998; Lewis 1992a]
it has been found that representations more sophisticated than this do not yield
significantly better effectiveness, thereby confirming similar results from IR [Salton
and Buckley 1988]. In particular, some authors have used phrases, rather than
individual words, as indexing terms [Fuhr et al. 1991; Sch¨utze et al. 1995; Tzeras
and Hartmann 1993], but the experimental results found to date have not been
uniformly encouraging, irrespectively of whether the notion of “phrase” is motivated
—syntactically, i.e. the phrase is such according to a grammar of the language (see
e.g. [Lewis 1992a]);
—statistically, i.e. the phrase is not grammatically such, but is composed of a
set/sequence of words whose patterns of contiguous occurrence in the collection
are statistically significant (see e.g. [Caropreso et al. 2001]).
Lewis [1992a] argues that the likely reason for the discouraging results is that,
although indexing languages based on phrases have superior semantic qualities,
they have inferior statistical qualities with respect to word-only indexing languages:
a phrase-only indexing language has “more terms, more synonymous or nearly
synonymous terms, lower consistency of assignment (since synonymous terms are
not assigned to the same documents), and lower document frequency for terms”
[Lewis 1992a, page 40]. Although his remarks are about syntactically motivated
phrases, they also apply to statistically motivated ones, although perhaps to a
smaller degree. A combination of the two approaches is probably the best way to
go: Tzeras and Hartmann [1993] obtained significant improvements by using noun
phrases obtained through a combination of syntactic and statistical criteria, where
a “crude” syntactic method was complemented by a statistical filter (only those
syntactic phrases that occurred at least three times in the positive examples of
a category ci were retained). It is likely that the final word on the usefulness of
phrase indexing in TC has still to be told, and investigations in this direction are
still being actively pursued [Caropreso et al. 2001; Mladeni´c and Grobelnik 1998].
As for issue (2), weights usually range between 0 and 1 (an exception is [Lewis
et al. 1996]), and for ease of exposition we will assume they always do. As a special
case, binary weights may be used (1 denoting presence and 0 absence of the term
4An exception to this is represented by learning approaches based on Hidden Markov Models [Denoyer et al. 2001; Frasconi et al. 2001].
Machine Learning in Automated Text Categorization · 13
in the document); whether binary or non-binary weights are used depends on the
classifier learning algorithm used. In the case of non-binary indexing, for determining the weight wkj of term tk in document dj any IR-style indexing technique
that represents a document as a vector of weighted terms may be used. Most of
the times, the standard tf idf function is used (see e.g. [Salton and Buckley 1988]),
defined as
tf idf(tk, dj ) = #(tk, dj ) · log |T r|
#T r(tk)
(1)
where #(tk, dj ) denotes the number of times tk occurs in dj , and #T r(tk) denotes
the document frequency of term tk, i.e. the number of documents in T r in which
tk occurs. This function embodies the intuitions that (i) the more often a term
occurs in a document, the more it is representative of its content, and (ii) the more
documents a term occurs in, the less discriminating it is5
. Note that this formula
(as most other indexing formulae) weights the importance of a term to a document
in terms of occurrence considerations only, thereby deeming of null importance
the order in which the terms occur in the document and the syntactic role they
play. In other words, the semantics of a document is reduced to the collective
lexical semantics of the terms that occur in it, thereby disregarding the issue of
compositional semantics (an exception are the representation techniques used for
Foil [Cohen 1995a] and Sleeping Experts [Cohen and Singer 1999]).
In order for the weights to fall in the [0,1] interval and for the documents to be
represented by vectors of equal length, the weights resulting from tf idf are often
normalized by cosine normalization, given by:
wkj =
tf idf(tk, dj )
qP|T |
s=1(tf idf(ts, dj ))2
(2)
Although normalized tf idf is the most popular one, other indexing functions have
also been used, including probabilistic techniques [G¨overt et al. 1999] or techniques
for indexing structured documents [Larkey and Croft 1996]. Functions different
from tf idf are especially needed when T r is not available in its entirety from the
start and #T r(tk) cannot thus be computed, as e.g. in adaptive filtering; in this
case approximations of tf idf are usually employed [Dagan et al. 1997, Section 4.3].
Before indexing, the removal of function words (i.e. topic-neutral words such as
articles, prepositions, conjunctions, etc.) is almost always performed (exceptions
include [Lewis et al. 1996; Nigam et al. 2000; Riloff 1995])6
. Concerning stemming
(i.e. grouping words that share the same morphological root), its suitability to TC
is controversial. Although, similarly to unsupervised term clustering (see Section
5.5.1) of which it is an instance, stemming has sometimes been reported to hurt
effectiveness (e.g. [Baker and McCallum 1998]), the recent tendency is to adopt it,
5There exist many variants of tf idf, that differ from each other in terms of logarithms, normalization or other correction factors. Formula 1 is just one of the possible instances of this class; see
[Salton and Buckley 1988; Singhal et al. 1996] for variations on this theme.
6One application of TC in which it would be inappropriate to remove function words is author
identification for documents of disputed paternity. In fact, as noted in [Manning and Sch¨utze
1999, page 589], “it is often the ‘little’ words that give an author away (for example, the relative
frequencies of words like because or though)”.
14 · F. Sebastiani
as it reduces both the dimensionality of the term space (see Section 5.3) and the
stochastic dependence between terms (see Section 6.2).
Depending on the application, either the full text of the document or selected
parts of it are indexed. While the former option is the rule, exceptions exist. For
instance, in a patent categorization application Larkey [1999] indexes only the title,
the abstract, the first 20 lines of the summary, and the section containing the claims
of novelty of the described invention. This approach is made possible by the fact
that documents describing patents are structured. Similarly, when a document title
is available, one can pay extra importance to the words it contains [Apt´e et al. 1994;
Cohen and Singer 1999; Weiss et al. 1999]. When documents are flat, identifying
the most relevant part of a document is instead a non-obvious task.
5.2 The Darmstadt Indexing Approach
The AIR/X system [Fuhr et al. 1991] occupies a special place in the literature on
indexing for TC. This system is the final result of the AIR project, one of the most
important efforts in the history of TC: spanning a duration of more than ten years
[Knorz 1982; Tzeras and Hartmann 1993], it has produced a system operatively
employed since 1985 in the classification of corpora of scientific literature of O(105
)
documents and O(104
) categories, and has had important theoretical spin-offs in
the field of probabilistic indexing [Fuhr 1989; Fuhr and Buckley 1991]7
.
The approach to indexing taken in AIR/X is known as the Darmstadt Indexing
Approach (DIA) [Fuhr 1985]. Here, “indexing” is used in the sense of Section
3.1, i.e. as using terms from a controlled vocabulary, and is thus a synonym of
TC (the DIA was later extended to indexing with free terms [Fuhr and Buckley
1991]). The idea that underlies the DIA is the use of a much wider set of “features”
than described in Section 5.1. All other approaches mentioned in this paper view
terms as the dimensions of the learning space, where terms may be single words,
stems, phrases, or (see Sections 5.5.1 and 5.5.2) combinations of any of these. In
contrast, the DIA considers properties (of terms, documents, categories, or pairwise
relationships among these) as basic dimensions of the learning space. Examples of
these are
—properties of a term tk: e.g. the idf of tk;
—properties of the relationship between a term tk and a document dj : e.g. the tf
of tk in dj ; or the location (e.g. in the title, or in the abstract) of tk within dj ;
—properties of a document dj : e.g. the length of dj ;
—properties of a category ci
: e.g. the training set generality of ci
.
For each possible document-category pair, the values of these features are collected
in a so-called relevance description vector ~rd(dj , ci). The size of this vector is determined by the number of properties considered, and is thus independent of specific
terms, categories or documents (for multivalued features, appropriate aggregation
7The AIR/X system, its applications (including the AIR/PHYS system [Biebricher et al. 1988],
an application of AIR/X to indexing physics literature), and its experiments, have also been richly
documented in a series of papers and doctoral theses written in German. The interested reader
may consult [Fuhr et al. 1991] for a detailed bibliography.
Machine Learning in Automated Text Categorization · 15
functions are applied in order to yield a single value to be included in ~rd(dj , ci)); in
this way an abstraction from specific terms, categories or documents is achieved.
The main advantage of this approach is the possibility to consider additional
features that can hardly be accounted for in the usual term-based approaches, e.g.
the location of a term within a document, or the certainty with which a phrase was
identified in a document. The term-category relationship is described by estimates,
derived from the training set, of the probability P(ci
|tk) that a document belongs to
category ci
, given that it contains term tk (the DIA association factor )
8
. Relevance
description vectors ~rd(dj , ci) are then the final representations that are used for the
classification of document dj under category ci
.
The essential ideas of the DIA – transforming the classification space by means
of abstraction and using a more detailed text representation than the standard
bag-of-words approach – have not been taken up by other researchers so far. For
new TC applications dealing with structured documents or categorization of Web
pages, these ideas may become of increasing importance.
5.3 Dimensionality reduction
Unlike in text retrieval, in TC the high dimensionality of the term space (i.e. the
large value of |T |) may be problematic. In fact, while typical algorithms used in text
retrieval (such as cosine matching) can scale to high values of |T |, the same does
not hold of many sophisticated learning algorithms used for classifier induction (e.g.
the LLSF algorithm of [Yang and Chute 1994]). Because of this, before classifier
induction one often applies a pass of dimensionality reduction (DR), whose effect
is to reduce the size of the vector space from |T | to |T '
| « |T |; the set T
'
is called
the reduced term set.
DR is also beneficial since it tends to reduce overfitting, i.e. the phenomenon
by which a classifier is tuned also to the contingent characteristics of the training
data rather than just the constitutive characteristics of the categories. Classifiers
which overfit the training data are good at re-classifying the data they have been
trained on, but much worse at classifying previously unseen data. Experiments
have shown that in order to avoid overfitting a number of training examples roughly
proportional to the number of terms used is needed; Fuhr and Buckley [1991, page
235] have suggested that 50-100 training examples per term may be needed in TC
tasks. This means that if DR is performed, overfitting may be avoided even if a
smaller amount of training examples is used. However, in removing terms the risk
is to remove potentially useful information on the meaning of the documents. It is
then clear that, in order to obtain optimal (cost-)effectiveness, the reduction process
must be performed with care. Various DR methods have been proposed, either from
the information theory or from the linear algebra literature, and their relative merits
have been tested by experimentally evaluating the variation in effectiveness that a
given classifier undergoes after application of the function to the term space.
There are two distinct ways of viewing DR, depending on whether the task is
performed locally (i.e. for each individual category) or globally:
8Association factors are called adhesion coefficients in many early papers on TC; see e.g. [Field
1975; Robertson and Harding 1984].
16 · F. Sebastiani
—local DR: for each category ci
, a set T
'
i
of terms, with |T '
i
| « |T |, is chosen for
classification under ci (see e.g. [Apt´e et al. 1994; Lewis and Ringuette 1994; Li
and Jain 1998; Ng et al. 1997; Sable and Hatzivassiloglou 2000; Sch¨utze et al.
1995; Wiener et al. 1995]). This means that different subsets of ~dj are used when
working with the different categories. Typical values are 10 = |T '
i
| = 50.
—global DR: a set T
' of terms, with |T '
| « |T |, is chosen for the classification
under all categories C = {c1, . . . , c|C|} (see e.g. [Caropreso et al. 2001; Mladeni´c
1998; Yang 1999; Yang and Pedersen 1997]).
This distinction usually does not impact on the choice of DR technique, since most
such techniques can be used (and have been used) for local and global DR alike
(supervised DR techniques – see Section 5.5.1 – are exceptions to this rule). In
the rest of this section we will assume that the global approach is used, although
everything we will say also applies to the local approach.
A second, orthogonal distinction may be drawn in terms of the nature of the
resulting terms:
—DR by term selection: T
'
is a subset of T ;
—DR by term extraction: the terms in T
' are not of the same type of the terms in
T (e.g. if the terms in T are words, the terms in T
' may not be words at all),
but are obtained by combinations or transformations of the original ones.
Unlike in the previous distinction, these two ways of doing DR are tackled by very
different techniques; we will address them separately in the next two sections.
5.4 Dimensionality reduction by term selection
Given a predetermined integer r, techniques for term selection (also called term
space reduction – TSR) attempt to select, from the original set T , the set T
' of
terms (with |T '
| « |T |) that, when used for document indexing, yields the highest
effectiveness. Yang and Pedersen [1997] have shown that TSR may even result in
a moderate (= 5%) increase in effectiveness, depending on the classifier, on the
aggressivity |T |
|T '
|
of the reduction, and on the TSR technique used.
Moulinier et al. [1996] have used a so-called wrapper approach, i.e. one in which T
'
is identified by means of the same learning method which will be used for building
the classifier [John et al. 1994]. Starting from an initial term set, a new term
set is generated by either adding or removing a term. When a new term set is
generated, a classifier based on it is built and then tested on a validation set. The
term set that results in the best effectiveness is chosen. This approach has the
advantage of being tuned to the learning algorithm being used; moreover, if local
DR is performed, different numbers of terms for different categories may be chosen,
depending on whether a category is or is not easily separable from the others.
However, the sheer size of the space of different term sets makes its cost prohibitive
for standard TC applications.
A computationally easier alternative is the filtering approach [John et al. 1994],
i.e. keeping the |T '
| « |T | terms that receive the highest score according to a
function that measures the “importance” of the term for the TC task. We will
explore this solution in the rest of this section.
Machine Learning in Automated Text Categorization · 17
5.4.1 Document frequency. A simple and effective global TSR function is the document frequency #T r(tk) of a term tk, i.e. only the terms that occur in the highest
number of documents are retained. In a series of experiments Yang and Pedersen
[1997] have shown that with #T r(tk) it is possible to reduce the dimensionality by
a factor of 10 with no loss in effectiveness (a reduction by a factor of 100 bringing
about just a small loss).
This seems to indicate that the terms occurring most frequently in the collection
are the most valuable for TC. As such, this would seem to contradict a well-known
“law” of IR, according to which the terms with low-to-medium document frequency
are the most informative ones [Salton and Buckley 1988]. But these two results do
not contradict each other, since it is well-known (see e.g. [Salton et al. 1975]) that
the large majority of the words occurring in a corpus have a very low document
frequency; this means that by reducing the term set by a factor of 10 using document
frequency, only such words are removed, while the words from low-to-medium to
high document frequency are preserved. Of course, stop words need to be removed
in advance, lest only topic-neutral words are retained [Mladeni´c 1998].
Finally, note that a slightly more empirical form of TSR by document frequency
is adopted by many authors, who remove all terms occurring in at most x training
documents (popular values for x range from 1 to 3), either as the only form of DR
[Maron 1961; Ittner et al. 1995] or before applying another more sophisticated form
[Dumais et al. 1998; Li and Jain 1998]. A variant of this policy is removing all terms
that occur at most x times in the training set (e.g. [Dagan et al. 1997; Joachims
1997]), with popular values for x ranging from 1 (e.g. [Baker and McCallum 1998])
to 5 (e.g. [Apt´e et al. 1994; Cohen 1995a]).
5.4.2 Other information-theoretic term selection functions. Other more sophisticated information-theoretic functions have been used in the literature, among
which the DIA association factor [Fuhr et al. 1991], chi-square [Caropreso et al.
2001; Galavotti et al. 2000; Sch¨utze et al. 1995; Sebastiani et al. 2000; Yang and
Pedersen 1997; Yang and Liu 1999], NGL coefficient [Ng et al. 1997; Ruiz and Srinivasan 1999], information gain [Caropreso et al. 2001; Larkey 1998; Lewis 1992a;
Lewis and Ringuette 1994; Mladeni´c 1998; Moulinier and Ganascia 1996; Yang and
Pedersen 1997; Yang and Liu 1999], mutual information [Dumais et al. 1998; Lam
et al. 1997; Larkey and Croft 1996; Lewis and Ringuette 1994; Li and Jain 1998;
Moulinier et al. 1996; Ruiz and Srinivasan 1999; Taira and Haruno 1999; Yang and
Pedersen 1997], odds ratio [Caropreso et al. 2001; Mladeni´c 1998; Ruiz and Srinivasan 1999], relevancy score [Wiener et al. 1995], and GSS coefficient [Galavotti
et al. 2000]. The mathematical definitions of these measures are summarized for
convenience in Table 19
. Here, probabilities are interpreted on an event space of
documents (e.g. P(tk, ci) denotes the probability that, for a random document x,
term tk does not occur in x and x belongs to category ci), and are estimated by
9For better uniformity Table 1 views all the TSR functions in terms of subjective probability. In
some cases such as #(tk, ci) and ?
2
(tk, ci) this is slightly artificial, since these two functions are
not usually viewed in probabilistic terms. The formulae refer to the “local” (i.e. category-specific)
forms of the functions, which again is slightly artificial in some cases (e.g. #(tk, ci)). Note that
the NGL and GSS coefficients are here named after their authors, since they had originally been
given names that might generate some confusion if used here.
18 · F. Sebastiani
Function Denoted by Mathematical form
Document frequency #(tk, ci) P(tk|ci)
DIA association factor z(tk, ci) P(ci|tk)
Information gain IG(tk, ci)
X
c?{ci,ci}
X
t?{tk,tk}
P(t, c) · log P(t, c)
P(t) · P(c)
Mutual information MI(tk, ci) log P(tk, ci)
P(tk) · P(ci)
Chi-square ?
2
(tk, ci)
|T r| · [P(tk, ci) · P(tk, ci) - P(tk, ci) · P(tk, ci)]2
P(tk) · P(tk) · P(ci) · P(ci)
NGL coefficient NGL(tk, ci)
p
|T r| · [P(tk, ci) · P(tk, ci) - P(tk, ci) · P(tk, ci)]
p
P(tk) · P(tk) · P(ci) · P(ci)
Relevancy score RS(tk, ci) log P(tk|ci) + d
P(tk|ci) + d
Odds Ratio OR(tk, ci)
P(tk|ci) · (1 - P(tk|ci))
(1 - P(tk|ci)) · P(tk|ci)
GSS coefficient GSS(tk, ci) P(tk, ci) · P(tk, ci) - P(tk, ci) · P(tk, ci)
Table 1. Main functions used for term space reduction purposes. Information gain is also known
as expected mutual information; it is used under this name by Lewis [1992a, page 44] and Larkey
[1998]. In the RS(tk, ci) formula d is a constant damping factor.
counting occurrences in the training set. All functions are specified “locally” to a
specific category ci
; in order to assess the value of a term tk in a “global”, categoryindependent sense, either the sum fsum(tk) = P|C|
i=1 f(tk, ci), or the weighted average fwavg(tk) = P|C|
i=1 P(ci)f(tk, ci), or the maximum fmax(tk) = max|C|
i=1 f(tk, ci)
of their category-specific values f(tk, ci) are usually computed.
These functions try to capture the intuition that the best terms for ci are the
ones distributed most differently in the sets of positive and negative examples of
ci
. However, interpretations of this principle vary across different functions. For
instance, in the experimental sciences ?
2
is used to measure how the results of an
observation differ (i.e. are independent) from the results expected according to an
initial hypothesis (lower values indicate lower dependence). In DR we measure how
independent tk and ci are. The terms tk with the lowest value for ?
2
(tk, ci) are
thus the most independent from ci
; since we are interested in the terms which are
not, we select the terms for which ?
2
(tk, ci) is highest.
While each TSR function has its own rationale, the ultimate word on its value
is the effectiveness it brings about. Various experimental comparisons of TSR
functions have thus been carried out [Caropreso et al. 2001; Galavotti et al. 2000;
Mladeni´c 1998; Yang and Pedersen 1997]. In these experiments most functions
listed in Table 1 (with the possible exception of M I) have improved on the results
of document frequency. For instance, Yang and Pedersen [1997] have shown that,
with various classifiers and various initial corpora, sophisticated techniques such
Machine Learning in Automated Text Categorization · 19
as IGsum(tk, ci) or ?
2
max(tk, ci) can reduce the dimensionality of the term space
by a factor of 100 with no loss (or even with a small increase) of effectiveness.
Collectively, the experiments reported in the above-mentioned papers seem to indicate that {ORsum, NGLsum, GSSmax} > {?
2
max, IGsum} > {#wavg, ?
2
wavg} »
{M Imax, M Iwavg}, where “>” means “performs better than”. However, it should
be noted that these results are just indicative, and that more general statements
on the relative merits of these functions could be made only as a result of comparative experiments performed in thoroughly controlled conditions and on a variety
of different situations (e.g. different classifiers, different initial corpora, . . . ).
5.5 Dimensionality reduction by term extraction
Given a predetermined |T '
| « |T |, term extraction attempts to generate, from
the original set T , a set T
' of “synthetic” terms that maximize effectiveness. The
rationale for using synthetic (rather than naturally occurring) terms is that, due to
the pervasive problems of polysemy, homonymy and synonymy, the original terms
may not be optimal dimensions for document content representation. Methods
for term extraction try to solve these problems by creating artificial terms that
do not suffer from them. Any term extraction method consists in (i) a method
for extracting the new terms from the old ones, and (ii) a method for converting
the original document representations into new representations based on the newly
synthesized dimensions. Two term extraction methods have been experimented in
TC, namely term clustering and latent semantic indexing.
5.5.1 Term clustering. Term clustering tries to group words with a high degree
of pairwise semantic relatedness, so that the groups (or their centroids, or a representative of them) may be used instead of the terms as dimensions of the vector
space. Term clustering is different from term selection, since the former tends to
address terms synonymous (or near-synonymous) with other terms, while the latter
targets non-informative terms10
.
Lewis [1992a] was the first to investigate the use of term clustering in TC. The
method he employed, called reciprocal nearest neighbour clustering, consists in creating clusters of two terms that are one the most similar to the other according to some measure of similarity. His results were inferior to those obtained by
single-word indexing, possibly due to a disappointing performance by the clustering
method: as Lewis [1992a, page 48] says, “The relationships captured in the clusters
are mostly accidental, rather than the systematic relationships that were hoped
for.”
Li and Jain [1998] view semantic relatedness between words in terms of their
co-occurrence and co-absence within training documents. By using this technique
in the context of a hierarchical clustering algorithm they witnessed only a marginal
effectiveness improvement; however, the small size of their experiment (see Section
6.11) hardly allows any definitive conclusion to be reached.
Both [Lewis 1992a; Li and Jain 1998] are examples of unsupervised clustering,
since clustering is not affected by the category labels attached to the documents.
Baker and McCallum [1998] provide instead an example of supervised clustering, as
10Some term selection methods, such as wrapper methods, also address the problem of redundancy.
20 · F. Sebastiani
the distributional clustering method they employ clusters together those terms that
tend to indicate the presence of the same category, or group of categories. Their
experiments, carried out in the context of a Na¨ive Bayes classifier (see Section
6.2), showed only a 2% effectiveness loss with an aggressivity of 1000, and even
showed some effectiveness improvement with less aggressive levels of reduction.
Later experiments by Slonim and Tishby [2001] have confirmed the potential of
supervised clustering methods for term extraction.
5.5.2 Latent semantic indexing. Latent semantic indexing (LSI – [Deerwester
et al. 1990]) is a DR technique developed in IR in order to address the problems deriving from the use of synonymous, near-synonymous and polysemous words
as dimensions of document representations. This technique compresses document
vectors into vectors of a lower-dimensional space whose dimensions are obtained
as combinations of the original dimensions by looking at their patterns of cooccurrence. In practice, LSI infers the dependence among the original terms from
a corpus and “wires” this dependence into the newly obtained, independent dimensions. The function mapping original vectors into new vectors is obtained by
applying a singular value decomposition to the matrix formed by the original document vectors. In TC this technique is applied by deriving the mapping function
from the training set and then applying it to training and test documents alike.
One characteristic of LSI is that the newly obtained dimensions are not, unlike in
term selection and term clustering, intuitively interpretable. However, they work
well in bringing out the “latent” semantic structure of the vocabulary used in the
corpus. For instance, Sch¨utze et al. [1995, page 235] discuss the classification under
category Demographic shifts in the U.S. with economic impact of a document that was indeed a positive test instance for the category, and that contained,
among others, the quite revealing sentence “The nation grew to 249.6 million
people in the 1980s as more Americans left the industrial and agricultural heartlands for the South and West”. The classifier decision was incorrect when local DR had been performed by ?
2
-based term selection retaining the
top original 200 terms, but was correct when the same task was tackled by means
of LSI. This well exemplifies how LSI works: the above sentence does not contain
any of the 200 terms most relevant to the category selected by ?
2
, but quite possibly the words contained in it have concurred to produce one or more of the LSI
higher-order terms that generate the document space of the category. As Sch¨utze
et al. [1995, page 230] put it, “if there is a great number of terms which all contribute a small amount of critical information, then the combination of evidence is
a major problem for a term-based classifier”. A drawback of LSI, though, is that if
some original term is particularly good in itself at discriminating a category, that
discrimination power may be lost in the new vector space.
Wiener et al. [1995] use LSI in two alternative ways: (i) for local DR, thus creating
several category-specific LSI representations, and (ii) for global DR, thus creating a
single LSI representation for the entire category set. Their experiments showed the
former approach to perform better than the latter, and both approaches to perform
better than simple TSR based on Relevancy Score (see Table 1).
Sch¨utze et al. [1995] experimentally compared LSI-based term extraction with
?
2
-based TSR using three different classifier learning techniques (namely, linear
Machine Learning in Automated Text Categorization · 21
discriminant analysis, logistic regression and neural networks). Their experiments
showed LSI to be far more effective than ?
2
for the first two techniques, while both
methods performed equally well for the neural network classifier.
For other TC works that use LSI or similar term extraction techniques see e.g.
[Hull 1994; Li and Jain 1998; Sch¨utze 1998; Weigend et al. 1999; Yang 1995].
6. INDUCTIVE CONSTRUCTION OF TEXT CLASSIFIERS
The inductive construction of text classifiers has been tackled in a variety of ways.
Here we will deal only with the methods that have been most popular in TC, but
we will also briefly mention the existence of alternative, less standard approaches.
We start by discussing the general form that a text classifier has. Let us recall
from Section 2.4 that there are two alternative ways of viewing classification: “hard”
(fully automated) classification and ranking (semi-automated) classification.
The inductive construction of a ranking classifier for category ci ? C usually
consists in the definition of a function CSVi
: D ? [0, 1] that, given a document
dj , returns a categorization status value for it, i.e. a number between 0 and 1 that,
roughly speaking, represents the evidence for the fact that dj ? ci
. Documents
are then ranked according to their CSVi value. This works for “document-ranking
TC”; “category-ranking TC” is usually tackled by ranking, for a given document
dj , its CSVi scores for the different categories in C = {c1, . . . , c|C|}.
The CSVi function takes up different meanings according to the learning method
used: for instance, in the “Na¨ive Bayes” approach of Section 6.2 CSVi(dj ) is defined
in terms of a probability, whereas in the “Rocchio” approach discussed in Section
6.7 CSVi(dj ) is a measure of vector closeness in |T |-dimensional space.
The construction of a “hard” classifier may follow two alternative paths. The
former consists in the definition of a function CSVi
: D ? {T, F}. The latter
consists instead in the definition of a function CSVi
: D ? [0, 1], analogous to the
one used for ranking classification, followed by the definition of a threshold ti such
that CSVi(dj ) = ti
is interpreted as T while CSVi(dj ) < ti
is interpreted as F
11
.
The definition of thresholds will be the topic of Section 6.1. In Sections 6.2 to
6.12 we will instead concentrate on the definition of CSVi
, discussing a number of
approaches that have been applied in the TC literature. In general we will assume
we are dealing with “hard” classification; it will be evident from the context how and
whether the approaches can be adapted to ranking classification. The presentation
of the algorithms will be mostly qualitative rather than quantitative, i.e. will focus
on the methods for classifier learning rather than on the effectiveness and efficiency
of the classifiers built by means of them; this will instead be the focus of Section 7.
6.1 Determining thresholds
There are various policies for determining the threshold ti
, also depending on the
constraints imposed by the application. The most important distinction is whether
the threshold is derived analytically or experimentally.
The former method is possible only in the presence of a theoretical result that
indicates how to compute the threshold that maximizes the expected value of the
11Alternative methods are possible, such as training a classifier for which some standard, predefined value such as 0 is the threshold. For ease of exposition we will not discuss them.
22 · F. Sebastiani
effectiveness function [Lewis 1995a]. This is typical of classifiers that output probability estimates of the membership of dj in ci (see Section 6.2) and whose effectiveness is computed by decision-theoretic measures such as utility (see Section 7.1.3);
we thus defer the discussion of this policy (which is called probability thresholding
in [Lewis 1995a]) to Section 7.1.3.
When such a theoretical result is not available one has to revert to the latter
method, which consists in testing different values for ti on a validation set and
choosing the value which maximizes effectiveness. We call this policy CSV thresholding [Cohen and Singer 1999; Schapire et al. 1998; Wiener et al. 1995]; it is also
called Scut in [Yang 1999]. Different ti
’s are typically chosen for the different ci
’s.
A second, popular experimental policy is proportional thresholding [Iwayama and
Tokunaga 1995; Larkey 1998; Lewis 1992a; Lewis and Ringuette 1994; Wiener et al.
1995], also called Pcut in [Yang 1999]. This policy consists in choosing the value of
ti for which gV a(ci) is closest to gT r(ci), and embodies the principle that the same
percentage of documents of both training and test set should be classified under ci
.
For obvious reasons, this policy does not lend itself to document-pivoted TC.
Sometimes, depending on the application, a fixed thresholding policy (aka “kper-doc” thresholding [Lewis 1992a] or Rcut [Yang 1999]) is applied, whereby it is
stipulated that a fixed number k of categories, equal for all dj ’s, are to be assigned
to each document dj . This is often used, for instance, in applications of TC to
automated document indexing [Field 1975; Lam et al. 1999]. Strictly speaking,
however, this is not a thresholding policy in the sense defined at the beginning of
Section 6, as it might happen that d
'
is classified under ci
, d
'' is not, and CSVi(d
'
) <
CSVi(d
''). Quite clearly, this policy is mostly at home with document-pivoted TC.
However, it suffers from a certain coarseness, as the fact that k is equal for all
documents (nor could this be otherwise) allows no fine-tuning.
In his experiments Lewis [1992a] found the proportional policy to be superior to probability thresholding when microaveraged effectiveness was tested but
slightly inferior with macroaveraging (see Section 7.1.1). Yang [1999] found instead
CSV thresholding to be superior to proportional thresholding (possibly due to her
category-specific optimization on a validation set), and found fixed thresholding to
be consistently inferior to the other two policies. The fact that these latter results
have been obtained across different classifiers no doubt reinforce them.
In general, aside from the considerations above, the choice of the thresholding
policy may also be influenced by the application; for instance, in applying a text
classifier to document indexing for Boolean systems a fixed thresholding policy
might be chosen, while a proportional or CSV thresholding method might be chosen
for Web page classification under hierarchical catalogues.
6.2 Probabilistic classifiers
Probabilistic classifiers (see [Lewis 1998] for a thorough discussion) view CSVi(dj )
in terms of P(ci
|
~dj ), i.e. the probability that a document represented by a vector
~dj = hw1j , . . . , w|T |j i of (binary or weighted) terms belongs to ci
, and compute this
probability by an application of Bayes’ theorem, given by
P(ci
|
~dj ) = P(ci)P(
~dj |ci)
P(
~dj )
(3)
Machine Learning in Automated Text Categorization · 23
In (3) the event space is the space of documents: P(d~
j ) is thus the probability
that a randomly picked document has vector ~dj as its representation, and P(ci) the
probability that a randomly picked document belongs to ci
.
The estimation of P(
~dj |ci) in (3) is problematic, since the number of possible
vectors ~dj is too high (the same holds for P(
~dj ), but for reasons that will be
clear shortly this will not concern us). In order to alleviate this problem it is
common to make the assumption that any two coordinates of the document vector
are, when viewed as random variables, statistically independent of each other; this
independence assumption is encoded by the equation
P(
~dj |ci) = Y
|T |
k=1
P(wkj |ci) (4)
Probabilistic classifiers that use this assumption are called Na¨ive Bayes classifiers,
and account for most of the probabilistic approaches to TC in the literature (see
e.g. [Joachims 1998; Koller and Sahami 1997; Larkey and Croft 1996; Lewis 1992a;
Lewis and Gale 1994; Li and Jain 1998; Robertson and Harding 1984]). The “na¨ive”
character of the classifier is due to the fact that usually this assumption is, quite
obviously, not verified in practice.
One of the best-known Na¨ive Bayes approaches is the binary independence classifier [Robertson and Sparck Jones 1976], which results from using binary-valued
vector representations for documents. In this case, if we write pki as short for
P(wkx = 1|ci), the P(wkj |ci) factors of (4) may be written as
P(wkj |ci) = p
wkj
ki (1 - pki)
1-wkj = ( pki
1 - pki
)
wkj (1 - pki) (5)
We may further observe that in TC the document space is partitioned into two
categories12
, ci and its complement ci
, such that P(ci
|
~dj ) = 1 - P(ci
|
~dj ). If we
plug in (4) and (5) into (3) and take logs we obtain
log P(ci
|
~dj ) = log P(ci) + (6)
X
|T |
k=1
wkj log pki
1 - pki
+
X
|T |
k=1
log(1 - pki) - log P(
~dj )
log(1 - P(ci
|
~dj )) = log(1 - P(ci)) + (7)
X
|T |
k=1
wkj log
pki
1 - pki
+
X
|T |
k=1
log(1 - pki
) - log P(d~
j )
where we write pki
as short for P(wkx = 1|ci). We may convert (6) and (7) into a
single equation by subtracting componentwise (7) from (6), thus obtaining
log P(ci
|
~dj )
1 - P(ci
|
~dj )
= log P(ci)
1 - P(ci)
+
X
|T |
k=1
wkj log
pki(1 - pki
)
pki
(1 - pki)
+
X
|T |
k=1
log 1 - pki
1 - pki
(8)
12Cooper [1995] has pointed out that in this case the full independence assumption of (4) is not
actually made in the Na¨ive Bayes classifier; the assumption needed here is instead the weaker
linked dependence assumption, which may be written as P (d~
j |ci)
P (d~
j |ci)
=
Q|T |
k=1
P (wkj |ci)
P (wkj |ci)
.
24 · F. Sebastiani
Note that P (ci|d~j )
1-P (ci|d~j)
is an increasing monotonic function of P(ci
|
~dj ), and may thus
be used directly as CSVi(dj ). Note also that log P (ci)
1-P (ci)
and P|T |
k=1 log 1-pki
1-pki
are constant for all documents, and may thus be disregarded13. Defining a classifier for category ci thus basically requires estimating the 2|T | parameters {p1i
, p1i
, . . . , p|T |i
, p|T |i
}
from the training data, which may be done in the obvious way. Note that in general
the classification of a given document does not require to compute a sum of |T | factors, as the presence of P|T |
k=1 wkj log pki(1-pki
)
pki
(1-pki) would imply; in fact, all the factors
for which wkj = 0 may be disregarded, and this accounts for the vast majority of
them, since document vectors are usually very sparse.
The method we have illustrated is just one of the many variants of the Na¨ive
Bayes approach, the common denominator of which is (4). A recent paper by
Lewis [1998] is an excellent roadmap on the various directions that research on
Na¨ive Bayes classifiers has taken; among these are the ones aiming
—to relax the constraint that document vectors should be binary-valued. This looks
natural, given that weighted indexing techniques (see e.g. [Fuhr 1989; Salton and
Buckley 1988]) accounting for the “importance” of tk for dj play a key role in IR.
—to introduce document length normalization. The value of log P (ci|d~j)
1-P (ci|d~j)
tends to
be more extreme (i.e. very high or very low) for long documents (i.e. documents
such that wkj = 1 for many values of k), irrespectively of their semantic relatedness to ci
, thus calling for length normalization. Taking length into account is
easy in non-probabilistic approaches to classification (see e.g. Section 6.7), but
is problematic in probabilistic ones (see [Lewis 1998, Section 5]). One possible
answer is to switch from an interpretation of Na¨ive Bayes in which documents are
events to one in which terms are events [Baker and McCallum 1998; McCallum
et al. 1998; Chakrabarti et al. 1998a; Guthrie et al. 1994]. This accounts for
document length naturally but, as noted in [Lewis 1998], has the drawback that
different occurrences of the same word within the same document are viewed as
independent, an assumption even more implausible than (4).
—to relax the independence assumption. This may be the hardest route to follow,
since this produces classifiers of higher computational cost and characterized by
harder parameter estimation problems [Koller and Sahami 1997]. Earlier efforts
in this direction within probabilistic text search (e.g. [van Rijsbergen 1977]) have
not shown the performance improvements that were hoped for. Recently, the
fact that the binary independence assumption seldom harms effectiveness has
also been given some theoretical justification [Domingos and Pazzani 1997].
The quotation of text search in the last paragraph is not casual. Unlike other types
of classifiers, the literature on probabilistic classifiers is inextricably intertwined
with that on probabilistic search systems (see [Crestani et al. 1998] for a review),
since these latter attempt to determine the probability that a document falls in the
13This is not true, however, if the “fixed thresholding” method of Section 6.1 is adopted. In fact,
for a fixed document dj the first and third factor in the formula above are different for different
categories, and may therefore influence the choice of the categories under which to file dj .
Machine Learning in Automated Text Categorization · 25
Fig. 2. A decision tree equivalent to the DNF rule of Figure 1. Edges are labelled by terms and
leaves are labelled by categories (underlining denotes negation).
category denoted by the query, and since they are the only search systems that take
relevance feedback, a notion essentially involving supervised learning, as central.
6.3 Decision tree classifiers
Probabilistic methods are quantitative (i.e. numeric) in nature, and as such have
sometimes been criticized since, effective as they may be, are not easily interpretable
by humans. A class of algorithms that do not suffer from this problem are symbolic
(i.e. non-numeric) algorithms, among which inductive rule learners (which we will
discuss in Section 6.4) and decision tree learners are the most important examples.
A decision tree (DT) text classifier (see e.g. [Mitchell 1996, Chapter 3]) is a
tree in which internal nodes are labelled by terms, branches departing from them
are labelled by tests on the weight that the term has in the test document, and
leafs are labelled by categories. Such a classifier categorizes a test document dj by
recursively testing for the weights that the terms labeling the internal nodes have
in vector ~dj , until a leaf node is reached; the label of this node is then assigned to
dj . Most such classifiers use binary document representations, and thus consist of
binary trees. An example DT is illustrated in Figure 2.
There are a number of standard packages for DT learning, and most DT approaches to TC have made use of one such package. Among the most popular ones
are ID3 (used in [Fuhr et al. 1991]), C4.5 (used in [Cohen and Hirsh 1998; Cohen
and Singer 1999; Joachims 1998; Lewis and Catlett 1994]) and C5 (used in [Li and
Jain 1998]). TC efforts based on experimental DT packages include [Dumais et al.
1998; Lewis and Ringuette 1994; Weiss et al. 1999].
A possible method for learning a DT for category ci consists in a “divide and
conquer” strategy of (i) checking whether all the training examples have the same
26 · F. Sebastiani
label (either ci or ci); (ii) if not, selecting a term tk, partitioning T r into classes
of documents that have the same value for tk, and placing each such class in a
separate subtree. The process is recursively repeated on the subtrees until each leaf
of the tree so generated contains training examples assigned to the same category ci
,
which is then chosen as the label for the leaf. The key step is the choice of the term
tk on which to operate the partition, a choice which is generally made according to
an information gain or entropy criterion. However, such a “fully grown” tree may
be prone to overfitting, as some branches may be too specific to the training data.
Most DT learning methods thus include a method for growing the tree and one for
pruning it, i.e. for removing the overly specific branches. Variations on this basic
schema for DT learning abound [Mitchell 1996, Section 3].
DT text classifiers have been used either as the main classification tool [Fuhr et al.
1991; Lewis and Catlett 1994; Lewis and Ringuette 1994], or as baseline classifiers
[Cohen and Singer 1999; Joachims 1998], or as members of classifier committees [Li
and Jain 1998; Schapire and Singer 2000; Weiss et al. 1999].
6.4 Decision rule classifiers
A classifier for category ci built by an inductive rule learning method consists of
a DNF rule, i.e. of a conditional rule with a premise in disjunctive normal form
(DNF), of the type illustrated in Figure 114. The literals (i.e. possibly negated
keywords) in the premise denote the presence (non-negated keyword) or absence
(negated keyword) of the keyword in the test document dj , while the clause head
denotes the decision to classify dj under ci
. DNF rules are similar to DTs in that
they can encode any Boolean function. However, an advantage of DNF rule learners
is that they tend to generate more compact classifiers than DT learners.
Rule learning methods usually attempt to select from all the possible covering
rules (i.e. rules that correctly classify all the training examples) the “best” one
according to some minimality criterion. While DTs are typically built by a topdown, “divide-and-conquer” strategy, DNF rules are often built in a bottom-up
fashion. Initially, every training example dj is viewed as a clause ?1, . . . , ?n ? ?i
,
where ?1, . . . , ?n are the terms contained in dj and ?i equals ci or ci according to
whether dj is a positive or negative example of ci
. This set of clauses is already a
DNF classifier for ci
, but obviously scores high in terms of overfitting. The learner
applies then a process of generalization in which the rule is simplified through a
series of modifications (e.g. removing premises from clauses, or merging clauses)
that maximize its compactness while at the same time not affecting the “covering”
property of the classifier. At the end of this process, a “pruning” phase similar in
spirit to that employed in DTs is applied, where the ability to correctly classify all
the training examples is traded for more generality.
DNF rule learners vary widely in terms of the methods, heuristics and criteria
employed for generalization and pruning. Among the DNF rule learners that have
been applied to TC are Charade [Moulinier and Ganascia 1996], DL-ESC [Li and
Yamanishi 1999], Ripper [Cohen 1995a; Cohen and Hirsh 1998; Cohen and Singer
14Many inductive rule learning algorithms build decision lists (i.e. arbitrarily nested if-then-else
clauses) instead of DNF rules; since the former may always be rewritten as the latter we will
disregard the issue.
Machine Learning in Automated Text Categorization · 27
1999], Scar [Moulinier et al. 1996], and Swap-1 [Apt´e et al. 1994].
While the methods above use rules of propositional logic (PL), research has also
been carried out using rules of first order logic (FOL), obtainable through the use of
inductive logic programming methods. Cohen [1995a] has extensively compared PL
and FOL learning in TC (for instance, comparing the PL learner Ripper with its
FOL version Flipper), and has found that the additional representational power
of FOL brings about only modest benefits.
6.5 Regression methods
Various TC efforts have used regression models (see e.g. [Fuhr and Pfeifer 1994;
Ittner et al. 1995; Lewis and Gale 1994; Sch¨utze et al. 1995]). Regression denotes the
approximation of a real-valued (instead than binary, as in the case of classification)
function F by means of a function F that fits the training data [Mitchell ? 1996,
page 236]. Here we will describe one such model, the Linear Least Squares Fit
(LLSF) applied to TC by Yang and Chute [1994]. In LLSF, each document dj has
two vectors associated to it: an input vector I(dj ) of |T | weighted terms, and an
output vector O(dj ) of |C| weights representing the categories (the weights for this
latter vector are binary for training documents, and are non-binary CSV s for test
documents). Classification may thus be seen as the task of determining an output
vector O(dj ) for test document dj , given its input vector I(dj ); hence, building a
classifier boils down to computing a |C| × |T | matrix Mˆ such that M I ˆ (dj ) = O(dj ).
LLSF computes the matrix from the training data by computing a linear leastsquares fit that minimizes the error on the training set according to the formula
Mˆ = arg minM kM I-OkF , where arg minM (x) stands as usual for the M for which
x is minimum, kV kF
def
=
qP|C|
i=1
P|T |
j=1 v
2
ij represents the so-called Frobenius norm
of a |C| ×|T | matrix, I is the |T | ×|T r| matrix whose columns are the input vectors
of the training documents, and O is the |C| × |T r| matrix whose columns are the
output vectors of the training documents. The Mˆ matrix is usually computed by
performing a singular value decomposition on the training set, and its generic entry
mˆ ik represents the degree of association between category ci and term tk.
The experiments of [Yang and Chute 1994; Yang and Liu 1999] indicate that
LLSF is one of the most effective text classifiers known to date. One of its disadvantages, though, is that the cost of computing the Mˆ matrix is much higher than
that of many other competitors in the TC arena.
6.6 On-line methods
A linear classifier for category ci
is a vector ~ci = hw1i
, . . . , w|T |ii belonging to
the same |T |-dimensional space in which documents are also represented, and such
that CSVi(dj ) corresponds to the dot product P|T |
k=1 wkiwkj of ~dj and ~ci
. Note that
when both classifier and document weights are cosine-normalized (see (2)), the dot
product between the two vectors corresponds to their cosine similarity, i.e.
S(ci
, dj ) = cos(a) =
P|T |
k=1 wki · wjk
qP|T |
k=1 w2
ki ·
qP|T |
k=1 w2
kj
which represents the cosine of the angle a that separates the two vectors. This is
28 · F. Sebastiani
the similarity measure between query and document computed by standard vectorspace IR engines, which means in turn that once a linear classifier has been built,
classification can be performed by invoking such an engine. Practically all search
engines have a dot product flavour to them, and can therefore be adapted to doing
TC with a linear classifier.
Methods for learning linear classifiers are often partitioned in two broad classes,
batch methods and on-line methods.
Batch methods build a classifier by analysing the training set all at once. Within
the TC literature, one example of a batch method is linear discriminant analysis,
a model of the stochastic dependence between terms that relies on the covariance
matrices of the categories [Hull 1994; Sch¨utze et al. 1995]. However, the foremost
example of a batch method is the Rocchio method; because of its importance in
the TC literature this will be discussed separately in Section 6.7. In this section we
will instead concentrate on on-line classifiers.
On-line (aka incremental) methods build a classifier soon after examining the
first training document, and incrementally refine it as they examine new ones. This
may be an advantage in the applications in which T r is not available in its entirety
from the start, or in which the “meaning” of the category may change in time,
as e.g. in adaptive filtering. This is also apt to applications (e.g. semi-automated
classification, adaptive filtering) in which we may expect the user of a classifier to
provide feedback on how test documents have been classified, as in this case further
training may be performed during the operating phase by exploiting user feedback.
A simple on-line method is the perceptron algorithm, first applied to TC in
[Sch¨utze et al. 1995; Wiener et al. 1995] and subsequently used in [Dagan et al.
1997; Ng et al. 1997]. In this algorithm, the classifier for ci
is first initialized by
setting all weights wki to the same positive value. When a training example dj
(represented by a vector ~dj of binary weights) is examined, the classifier built so
far classifies it. If the result of the classification is correct nothing is done, while if
it is wrong the weights of the classifier are modified: if dj was a positive example of
ci then the weights wki of “active terms” (i.e. the terms tk such that wkj = 1) are
“promoted” by increasing them by a fixed quantity a > 0 (called learning rate),
while if dj was a negative example of ci then the same weights are “demoted” by
decreasing them by a. Note that when the classifier has reached a reasonable level
of effectiveness, the fact that a weight wki is very low means that tk has negatively
contributed to the classification process so far, and may thus be discarded from the
representation. We may then see the perceptron algorithm (as all other incremental
learning methods) as allowing for a sort of “on-the-fly term space reduction” [Dagan
et al. 1997, Section 4.4]. The perceptron classifier has shown a good effectiveness
in all the experiments quoted above.
The perceptron is an additive weight-updating algorithm. A multiplicative variant of it is Positive Winnow [Dagan et al. 1997], which differs from perceptron
because two different constants a1 > 1 and 0 < a2 < 1 are used for promoting and
demoting weights, respectively, and because promotion and demotion are achieved
by multiplying, instead of adding, by a1 and a2. Balanced Winnow [Dagan
et al. 1997] is a further variant of Positive Winnow, in which the classifier consists of two weights w
+
ki and w
-
ki for each term tk; the final weight wki used in
computing the dot product is the difference w
+
ki - w
-
ki. Following the misclassifica-
Machine Learning in Automated Text Categorization · 29
tion of a positive instance, active terms have their w
+
ki weight promoted and their
w
-
ki weight demoted, whereas in the case of a negative instance it is w
+
ki that gets
demoted while w
-
ki gets promoted (for the rest, promotions and demotions are as in
Positive Winnow). Balanced Winnow allows negative wki weights, while in
the perceptron and in Positive Winnow the wki weights are always positive. In
experiments conducted by Dagan et al. [1997], Positive Winnow showed a better
effectiveness than perceptron but was in turn outperformed by (Dagan et al.’s own
version of) Balanced Winnow.
Other on-line methods for building text classifiers are Widrow-Hoff, a refinement of it called Exponentiated Gradient (both applied for the first time to TC
in [Lewis et al. 1996]) and Sleeping Experts [Cohen and Singer 1999], a version
of Balanced Winnow. While the first is an additive weight-updating algorithm,
the second and third are multiplicative. Key differences with the previously described algorithms are that these three algorithms (i) update the classifier not only
after misclassifying a training example, but also after classifying it correctly, and
(ii) update the weights corresponding to all terms (instead of just active ones).
Linear classifiers lend themselves to both category-pivoted and document-pivoted
TC. For the former the classifier ~ci
is used, in a standard search engine, as a query
against the set of test documents, while for the latter the vector ~dj representing
the test document is used as a query against the set of classifiers {~c1, . . . , ~c|C|}.
6.7 The Rocchio method
Some linear classifiers consist of an explicit profile (or prototypical document) of the
category. This has obvious advantages in terms of interpretability, as such a profile
is more readily understandable by a human than, say, a neural network classifier.
Learning a linear classifier is often preceded by local TSR; in this case, a profile
of ci
is a weighted list of the terms whose presence or absence is most useful for
discriminating ci
.
The Rocchio method is used for inducing linear, profile-style classifiers. It relies
on an adaptation to TC of the well-known Rocchio’s formula for relevance feedback
in the vector-space model, and it is perhaps the only TC method rooted in the IR
tradition rather than in the ML one. This adaptation was first proposed by Hull
[1994], and has been used by many authors since then, either as an object of research
in its own right [Ittner et al. 1995; Joachims 1997; Sable and Hatzivassiloglou 2000;
Schapire et al. 1998; Singhal et al. 1997], or as a baseline classifier [Cohen and
Singer 1999; Galavotti et al. 2000; Joachims 1998; Lewis et al. 1996; Schapire and
Singer 2000; Sch¨utze et al. 1995], or as a member of a classifier committee [Larkey
and Croft 1996] (see Section 6.11).
Rocchio’s method computes a classifier ~ci = hw1i
, . . . , w|T |ii for category ci by
means of the formula
wki = ß ·
X
{dj?P OSi}
wkj
|P OSi
|
- ? ·
X
{dj?NEGi}
wkj
|NEGi
|
where wkj is the weight of tk in document dj , P OSi = {dj ? T r | F( ? dj , ci) = T } and
NEGi = {dj ? T r | F( ? dj , ci) = F}. In this formula, ß and ? are control parameters
that allow setting the relative importance of positive and negative examples. For
instance, if ß is set to 1 and ? to 0 (as e.g. in [Dumais et al. 1998; Hull 1994;
30 · F. Sebastiani
Fig. 3. A comparison between the TC behaviour of (a) the Rocchio classifier, and (b) the k-NN
classifier. Small crosses and circles denote positive and negative training instances, respectively.
The big circles denote the “influence area” of the classifier. Note that, for ease of illustration,
document similarities are here viewed in terms of Euclidean distance rather than, as more common,
in terms of dot product or cosine.
Joachims 1998; Sch¨utze et al. 1995]), the profile of ci
is the centroid of its positive
training examples. A classifier built by means of the Rocchio method rewards
the closeness of a test document to the centroid of the positive training examples,
and its distance from the centroid of the negative training examples. The role of
negative examples is usually de-emphasized, by setting ß to a high value and ? to
a low one (e.g. Cohen and Singer [1999], Ittner et al. [1995], and Joachims [1997]
use ß = 16 and ? = 4).
This method is quite easy to implement, and is also quite efficient, since learning
a classifier basically comes down to averaging weights. In terms of effectiveness,
instead, a drawback is that if the documents in the category tend to occur in
disjoint clusters (e.g. a set of newspaper articles lebelled with the Sports category
and dealing with either boxing or rock-climbing), such a classifier may miss most of
them, as the centroid of these documents may fall outside all of these clusters (see
Figure 3a). More generally, a classifier built by the Rocchio method, as all linear
classifiers, has the disadvantage that it divides the space of documents linearly.
This situation is graphically depicted in Figure 3a, where documents are classified
within ci
if and only if they fall within the circle. Note that even most of the
positive training examples would not be classified correctly by the classifier.
6.7.1 Enhancements to the basic Rocchio framework. One issue in the application of the Rocchio formula to profile extraction is whether the set NEGi should
be considered in its entirety, or whether a well-chosen sample of it, such as the
set NP OSi of near-positives (defined as “the most positive amongst the negative
training examples”), should be selected from it, yielding
wki = ß ·
X
{dj?P OSi}
wkj
|P OSi
|
- ? ·
X
{dj?NP OSi}
wkj
|NP OSi
|
Machine Learning in Automated Text Categorization · 31
The P
{dj?NP OSi}
wkj
|NP OSi|
factor is more significant than P
{dj?NEGi}
wkj
|NEGi|
, since
near-positives are the most difficult documents to tell apart from the positives. Using near-positives corresponds to the query zoning method proposed for IR by
Singhal et al. [1997]. This method originates from the observation that when the
original Rocchio formula is used for relevance feedback in IR, near-positives tend to
be used rather than generic negatives, as the documents on which user judgments
are available are among the ones that had scored highest in the previous ranking.
Early applications of the Rocchio formula to TC (e.g. [Hull 1994; Ittner et al. 1995])
generally did not make a distinction between near-positives and generic negatives.
In order to select the near-positives Schapire et al. [1998] issue a query, consisting of
the centroid of the positive training examples, against a document base consisting
of the negative training examples; the top-ranked ones are the most similar to this
centroid, and are then the near-positives. Wiener et al. [1995] instead equate the
near-positives of ci to the positive examples of the sibling categories of ci
, as in
the application they work on (TC with hierarchical category sets) the notion of a
“sibling category of ci” is well-defined. A similar policy is also adopted in [Ng et al.
1997; Ruiz and Srinivasan 1999; Weigend et al. 1999].
By using query zoning plus other enhancements (TSR, statistical phrases, and
a method called dynamic feedback optimization), Schapire et al. [1998] have found
that a Rocchio classifier can achieve an effectiveness comparable to that of a stateof-the-art ML method such as “boosting” (see Section 6.11.1) while being 60 times
quicker to train. These recent results will no doubt bring about a renewed interest
for the Rocchio classifier, previously considered an underperformer [Cohen and
Singer 1999; Joachims 1998; Lewis et al. 1996; Sch¨utze et al. 1995; Yang 1999].
6.8 Neural networks
A neural network (NN) text classifier is a network of units, where the input units
represent terms, the output unit(s) represent the category or categories of interest,
and the weights on the edges connecting units represent dependence relations. For
classifying a test document dj , its term weights wkj are loaded into the input units;
the activation of these units is propagated forward through the network, and the
value of the output unit(s) determines the categorization decision(s). A typical
way of training NNs is backpropagation, whereby the term weights of a training
document are loaded into the input units, and if a misclassification occurs the error
is “backpropagated” so as to change the parameters of the network and eliminate
or minimize the error.
The simplest type of NN classifier is the perceptron [Dagan et al. 1997; Ng et al.
1997], which is a linear classifier and as such has been extensively discussed in
Section 6.6. Other types of linear NN classifiers implementing a form of logistic
regression have also been proposed and tested by Sch¨utze et al. [1995] and Wiener
et al. [1995], yielding very good effectiveness.
A non-linear NN [Lam and Lee 1999; Ruiz and Srinivasan 1999; Sch¨utze et al.
1995; Weigend et al. 1999; Wiener et al. 1995; Yang and Liu 1999] is instead a
network with one or more additional “layers” of units, which in TC usually represent
higher-order interactions between terms that the network is able to learn. When
comparative experiments relating non-linear NNs to their linear counterparts have
been performed, the former have yielded either no improvement [Sch¨utze et al.
32 · F. Sebastiani
1995] or very small improvements [Wiener et al. 1995] over the latter.
6.9 Example-based classifiers
Example-based classifiers do not build an explicit, declarative representation of the
category ci
, but rely on the category labels attached to the training documents
similar to the test document. These methods have thus been called lazy learners,
since “they defer the decision on how to generalize beyond the training data until
each new query instance is encountered” [Mitchell 1996, pag 244].
The first application of example-based methods (aka memory-based reasoning
methods) to TC is due to Creecy, Masand and colleagues [Creecy et al. 1992;
Masand et al. 1992]; examples include [Joachims 1998; Lam et al. 1999; Larkey
1998; Larkey 1999; Li and Jain 1998; Yang and Pedersen 1997; Yang and Liu 1999].
Our presentation of the example-based approach will be based on the k-NN (for “k
nearest neighbours”) algorithm used by Yang [1994]. For deciding whether dj ? ci
,
k-NN looks at whether the k training documents most similar to dj also are in
ci
; if the answer is positive for a large enough proportion of them, a positive decision is taken, and a negative decision is taken otherwise. Actually, Yang’s is a
distance-weighted version of k-NN (see e.g. [Mitchell 1996, Section 8.2.1]), since the
fact that a most similar document is in ci
is weighted by its similarity with the test
document. Classifying dj by means of k-NN thus comes down to computing
CSVi(dj ) = X
dz? T rk(dj)
RSV (dj , dz) · [[F( ? dz, ci)]] (9)
where T rk(dj ) is the set of the k documents dz which maximize RSV (dj , dz) and
[[a]] = 
1 if a = T
0 if a = F
The thresholding methods of Section 6.1 can then be used to convert the real-valued
CSVi
’s into binary categorization decisions. In (9), RSV (dj , dz) represents some
measure or semantic relatedness between a test document dj and a training document dz; any matching function, be it probabilistic (as used in [Larkey and Croft
1996]) or vector-based (as used in [Yang 1994]), from a ranked IR system may be
used for this purpose. The construction of a k-NN classifier also involves determining (experimentally, on a validation set) a threshold k that indicates how many topranked training documents have to be considered for computing CSVi(dj ). Larkey
and Croft [1996] use k = 20, while Yang [1994, 1999] has found 30 = k = 45 to yield
the best effectiveness. Anyhow, various experiments have shown that increasing the
value of k does not significantly degrade the performance.
Note that k-NN, unlike linear classifiers, does not divide the document space
linearly, hence does not suffer from the problem discussed at the end of Section
6.7. This is graphically depicted in Figure 3b, where the more “local” character of
k-NN with respect to Rocchio can be appreciated.
This method is naturally geared towards document-pivoted TC, since ranking the
training documents for their similarity with the test document can be done once
for all categories. For category-pivoted TC one would need to store the document
ranks for each test document, which is obviously clumsy; DPC is thus de facto the
only reasonable way to use k-NN.
Machine Learning in Automated Text Categorization · 33
A number of different experiments (see Section 7.3) have shown k-NN to be quite
effective. However, its most important drawback is its inefficiency at classification
time: while e.g. with a linear classifier only a dot product needs to be computed
to classify a test document, k-NN requires the entire training set to be ranked
for similarity with the test document, which is much more expensive. This is a
drawback of “lazy” learning methods, since they do not have a true training phase
and thus defer all the computation to classification time.
6.9.1 Other example-based techniques. Various example-based techniques have
been used in the TC literature. For example, Cohen and Hirsh [1998] implement
an example-based classifier by extending standard relational DBMS technology with
“similarity-based soft joins”. In their Whirl system they use the scoring function
CSVi(dj ) = 1 -
Y
dz? T rk(dj )
(1 - RSV (dj , dz))[[F( ? dz,ci)]]
as an alternative to (9), obtaining a small but statistically significant improvement
over a version of Whirl using (9). In their experiments this technique outperformed
a number of other classifiers, such as a C4.5 decision tree classifier and the Ripper
CNF rule-based classifier.
A variant of the basic k-NN approach is proposed by Galavotti et al. [2000], who
reinterpret (9) by redefining [[a]] as
[[a]] = 
1 if a = T
-1 if a = F
The difference from the original k-NN approach is that if a training document
dz similar to the test document dj does not belong to ci
, this information is not
discarded but weights negatively in the decision to classify dj under ci
.
A combination of profile- and example-based methods is presented in [Lam and
Ho 1998]. In this work a k-NN system is fed generalized instances (GIs) in place of
training documents. This approach may be seen as the result of
—clustering the training set, thus obtaining a set of clusters Ki = {ki1, . . . , ki|Ki|};
—building a profile G(kiz ) (“generalized instance”) from the documents belonging
to cluster kiz by means of some algorithm for learning linear classifiers (e.g.
Rocchio, Widrow-Hoff);
—applying k-NN with profiles in place of training documents, i.e. computing
CSVi(dj )
def
=
X
kiz?Ki
RSV (dj , G(kiz )) ·
|{dj ? kiz| F( ? dj , ci) = T }|
|{dj ? kiz}| ·
|{dj ? kiz}|
|T r|
=
X
kiz?Ki
RSV (dj , G(kiz )) ·
|{dj ? kiz| F( ? dj , ci) = T }|
|T r|
(10)
where |{dj?kiz| F( ? dj,ci)=T}|
|{dj?kiz}| represents the “degree” to which G(kiz ) is a positive
instance of ci
, and |{dj?kiz}|
|T r|
represents its weight within the entire process.
This exploits the superior effectiveness (see Figure 3) of k-NN over linear classifiers
while at the same time avoiding the sensitivity of k-NN to the presence of “outliers”
34 · F. Sebastiani
Fig. 4. Learning support vector classifiers. The small crosses and circles represent positive and
negative training examples, respectively, whereas lines represent decision surfaces. Decision surface
si (indicated by the thicker line) is, among those shown, the best possible one, as it is the middle
element of the widest set of parallel decision surfaces (i.e. its minimum distance to any training
example is maximum). Small boxes indicate the support vectors.
(i.e. positive instances of ci that “lie out” of the region where most other positive
instances of ci are located) in the training set.
6.10 Building classifiers by support vector machines
The support vector machine (SVM) method has been introduced in TC by Joachims
[1998, 1999] and subsequently used in [Drucker et al. 1999; Dumais et al. 1998; Dumais and Chen 2000; Klinkenberg and Joachims 2000; Taira and Haruno 1999;
Yang and Liu 1999]. In geometrical terms, it may be seen as the attempt to find,
among all the surfaces s1, s2, . . . in |T |-dimensional space that separate the positive from the negative training examples (decision surfaces), the si that separates
the positives from the negatives by the widest possible margin, i.e. such that the
separation property is invariant with respect to the widest possible traslation of si
.
This idea is best understood in the case in which the positives and the negatives
are linearly separable, in which case the decision surfaces are (|T |-1)-hyperplanes.
In the 2-dimensional case of Figure 4, various lines may be chosen as decision
surfaces. The SVM method chooses the middle element from the “widest” set of
parallel lines, i.e. from the set in which the maximum distance between two elements
in the set is highest. It is noteworthy that this “best” decision surface is determined
by only a small set of training examples, called the support vectors.
The method described is applicable also to the case in which the positives and the
negatives are not linearly separable. Yang and Liu [1999] experimentally compared
the linear case (namely, when the assumption is made that the categories are linearly
separable) with the non-linear case on a standard benchmark, and obtained slightly
better results in the former case.
As argued by Joachims [1998], SVMs offer two important advantages for TC:
Machine Learning in Automated Text Categorization · 35
—term selection is often not needed, as SVMs tend to be fairly robust to overfitting
and can scale up to considerable dimensionalities;
—no human and machine effort in parameter tuning on a validation set is needed, as
there is a theoretically motivated, “default” choice of parameter settings, which
has also been shown to provide the best effectiveness.
Dumais et al. [1998] have applied a novel algorithm for training SVMs which brings
about training speeds comparable to computationally easy learners such as Rocchio.
6.11 Classifier committees
Classifier committees (aka ensembles) are based on the idea that, given a task that
requires expert knowledge to perform, k experts may be better than one if their
individual judgments are appropriately combined. In TC, the idea is to apply k
different classifiers F1, . . . , Fk to the same task of deciding whether dj ? ci
, and then
combine their outcome appropriately. A classifier committee is then characterized
by (i) a choice of k classifiers, and (ii) a choice of a combination function.
Concerning issue (i), it is known from the ML literature that, in order to guarantee good effectiveness, the classifiers forming the committee should be as independent as possible [Tumer and Ghosh 1996]. The classifiers may differ for the indexing
approach used, or for the inductive method, or both. Within TC, the avenue which
has been explored most is the latter (to our knowledge the only example of the
former is [Scott and Matwin 1999]).
Concerning issue (ii), various rules have been tested. The simplest one is majority
voting (MV), whereby the binary outputs of the k classifiers are pooled together,
and the classification decision that reaches the majority of k+1
2
votes is taken (k
obviously needs to be an odd number) [Li and Jain 1998; Liere and Tadepalli 1997].
This method is particularly suited to the case in which the committee includes
classifiers characterized by a binary decision function CSVi
: D ? {T, F}. A
second rule is weighted linear combination (WLC), whereby a weighted sum of the
CSVi
’s produced by the k classifiers yields the final CSVi
. The weights wj reflect
the expected relative effectiveness of classifiers Fj , and are usually optimized on
a validation set [Larkey and Croft 1996]. Another policy is dynamic classifier
selection (DCS), whereby among committee {F1, . . . , Fk} the classifier Ft most
effective on the l validation examples most similar to dj is selected, and its judgment
adopted by the committee [Li and Jain 1998]. A still different policy, somehow
intermediate between WLC and DCS, is adaptive classifier combination (ACC),
whereby the judgments of all the classifiers in the committee are summed together,
but their individual contribution is weighted by their effectiveness on the l validation
examples most similar to dj [Li and Jain 1998].
Classifier committees have had mixed results in TC so far. Larkey and Croft
[1996] have used combinations of Rocchio, Na¨ive Bayes and k-NN, all together or
in pairwise combinations, using a WLC rule. In their experiments the combination
of any two classifiers outperformed the best individual classifier (k-NN), and the
combination of the three classifiers improved an all three pairwise combinations.
These results would seem to give strong support to the idea that classifier committees can somehow profit from the complementary strengths of their individual
members. However, the small size of the test set used (187 documents) suggests
36 · F. Sebastiani
that more experimentation is needed before conclusions can be drawn.
Li and Jain [1998] have tested a committee formed of (various combinations of)
a Na¨ive Bayes classifier, an example-based classifier, a decision tree classifier, and
a classifier built by means of their own “subspace method”; the combination rules
they have worked with are MV, DCS and ACC. Only in the case of a committee
formed by Na¨ive Bayes and the subspace classifier combined by means of ACC
the committee has outperformed, and by a narrow margin, the best individual
classifier (for every attempted classifier combination ACC gave better results than
MV and DCS). This seems discouraging, especially in the light of the fact that
the committee approach is computationally expensive (its cost trivially amounts
to the sum of the costs of the individual classifiers plus the cost incurred for the
computation of the combination rule). Again, it has to be remarked that the small
size of their experiment (two test sets of less than 700 documents each were used)
does not allow to draw definitive conclusions on the approaches adopted.
6.11.1 Boosting. The boosting method [Schapire et al. 1998; Schapire and Singer
2000] occupies a special place in the classifier committees literature, since the k
classifiers F1, . . . , Fk forming the committee are obtained by the same learning
method (here called the weak learner ). The key intuition of boosting is that the
k classifiers should be trained not in a conceptually parallel and independent way,
as in the committees described above, but sequentially. In this way, in training
classifier Fi one may take into account how classifiers F1, . . . , Fi-1 perform on
the training examples, and concentrate on getting right those examples on which
F1, . . . , Fi-1 have performed worst.
Specifically, for learning classifier Ft each hdj , cii pair is given an “importance
weight” h
t
ij (where h
1
ij is set to be equal for all hdj , cii pairs15), which represents how
hard to get a correct decision for this pair was for classifiers F1, . . . , Ft-1. These
weights are exploited in learning Ft, which will be specially tuned to correctly solve
the pairs with higher weight. Classifier Ft is then applied to the training documents,
and as a result weights h
t
ij are updated to h
t+1
ij ; in this update operation, pairs
correctly classified by Ft will have their weight decreased, while pairs misclassified
by Ft will have their weight increased. After all the k classifiers have been built, a
weighted linear combination rule is applied to yield the final committee.
In the BoosTexter system [Schapire and Singer 2000], two different boosting
algorithms are tested, using a one-level decision tree weak learner. The former
algorithm (AdaBoost.MH, simply called AdaBoost in [Schapire et al. 1998]) is
explicitly geared towards the maximization of microaveraged effectiveness, whereas
the latter (AdaBoost.MR) is aimed at minimizing ranking loss (i.e. at getting a
correct category ranking for each individual document). In experiments conducted
over three different test collections, Schapire et al. [1998] have shown AdaBoost
to outperform Sleeping Experts, a classifier that had proven quite effective in
the experiments of [Cohen and Singer 1999]. Further experiments by Schapire and
Singer [2000] showed AdaBoost to outperform, aside from Sleeping Experts, a
Na¨ive Bayes classifier, a standard (non-enhanced) Rocchio classifier, and Joachims’
15Schapire et al. [1998] also show that a simple modification of this policy allows optimization of
the classifier based on “utility” (see Section 7.1.3).
Machine Learning in Automated Text Categorization · 37
[1997] PrTFIDF classifier.
A boosting algorithm based on a “committee of classifier sub-committees” that
improves on the effectiveness and (especially) the efficiency of AdaBoost.MH
is presented in [Sebastiani et al. 2000]. An approach similar to boosting is also
employed by Weiss et al. [1999], who experiment with committees of decision trees
each having an average of 16 leaves (hence much more complex than the simple
2-leaves trees used in [Schapire and Singer 2000]), eventually combined by using
the simple MV rule as a combination rule; similarly to boosting, a mechanism for
emphasising documents that have been misclassified by previous decision trees is
used. Boosting-based approaches have also been employed in [Escudero et al. 2000;
Iyer et al. 2000; Kim et al. 2000; Li and Jain 1998; Myers et al. 2000].
6.12 Other methods
Although in the previous sections we have tried to give an overview as complete
as possible of the learning approaches proposed in the TC literature, it would be
hardly possible to be exhaustive. Some of the learning approaches adopted do
not fall squarely under one or the other class of algorithms, or have remained
somehow isolated attempts. Among these, the most noteworthy are the ones based
on Bayesian inference networks [Dumais et al. 1998; Lam et al. 1997; Tzeras and
Hartmann 1993], genetic algorithms [Clack et al. 1997; Masand 1994], and maximum
entropy modelling [Manning and Sch¨utze 1999].
7. EVALUATION OF TEXT CLASSIFIERS
As for text search systems, the evaluation of document classifiers is typically conducted experimentally, rather than analytically. The reason is that, in order to evaluate a system analytically (e.g. proving that the system is correct and complete)
we would need a formal specification of the problem that the system is trying to
solve (e.g. with respect to what correctness and completeness are defined), and the
central notion of TC (namely, that of membership of a document in a category) is,
due to its subjective character, inherently non-formalisable.
The experimental evaluation of a classifier usually measures its effectiveness
(rather than its efficiency), i.e. its ability to take the right classification decisions.
7.1 Measures of text categorization effectiveness
7.1.1 Precision and recall. Classification effectiveness is usually measured in terms
of the classic IR notions of precision (p) and recall (?), adapted to the case of
TC. Precision wrt ci (pi) is defined as the conditional probability P(F( ? dx, ci) =
T |F(dx, ci) = T ), i.e. as the probability that if a random document dx is classified under ci
, this decision is correct. Analogously, recall wrt ci (?i) is defined as
P(F(dx, ci) = T | F( ? dx, ci) = T ), i.e. as the probability that, if a random document
dx ought to be classified under ci
, this decision is taken. These category-relative
values may be averaged, in a way to be discussed shortly, to obtain p and ?, i.e.
values global to the entire category set. Borrowing terminology from logic, p may
be viewed as the “degree of soundness” of the classifier wrt C, while ? may be
viewed as its “degree of completeness” wrt C. As defined here, pi and ?i are to be
understood as subjective probabilities, i.e. as measuring the expectation of the user
that the system will behave correctly when classifying an unseen document under
38 · F. Sebastiani
Category expert judgments
ci YES NO
classifier YES T Pi F Pi
judgments NO F Ni T Ni
Table 2. The contingency table for category ci.
Category set expert judgments
C = {c1, . . . , c|C|} YES NO
classifier YES T P =
X
|C|
i=1
T Pi F P =
X
|C|
i=1
F Pi
judgments NO F N =
X
|C|
i=1
F Ni T N =
X
|C|
i=1
T Ni
Table 3. The global contingency table.
ci
. These probabilities may be estimated in terms of the contingency table for ci
on a given test set (see Table 2). Here, F Pi (false positives wrt ci
, aka errors of
commission) is the number of test documents incorrectly classified under ci
; T Ni
(true negatives wrt ci), T Pi (true positives wrt ci) and F Ni (false negatives wrt ci
,
aka errors of omission) are defined accordingly. Estimates (indicated by carets) of
precision wrt ci and recall wrt ci may thus be obtained as
pˆi =
T Pi
T Pi + F Pi
?ˆi =
T Pi
T Pi + F Ni
For obtaining estimates of p and ?, two different methods may be adopted:
—microaveraging: p and ? are obtained by summing over all individual decisions:
pˆ
µ =
T P
T P + F P
=
P|C|
i=1 T Pi
P|C|
i=1(T Pi + F Pi)
?ˆ
µ =
T P
T P + F N
=
P|C|
i=1 T Pi
P|C|
i=1(T Pi + F Ni)
where “µ” indicates microaveraging. The “global” contingency table (Table 3) is
thus obtained by summing over category-specific contingency tables.
—macroaveraging : precision and recall are first evaluated “locally” for each category, and then “globally” by averaging over the results of the different categories:
pˆ
M =
P|C|
i=1 pˆi
|C| ?ˆ
M =
P|C|
i=1 ?ˆi
|C|
where “M” indicates macroaveraging.
These two methods may give quite different results, especially if the different categories have very different generality. For instance, the ability of a classifier to
behave well also on categories with low generality (i.e. categories with few positive training instances) will be emphasized by macroaveraging and much less so by
Machine Learning in Automated Text Categorization · 39
microaveraging. Whether one or the other should be used obviously depends on
the application requirements. From now on, we will assume that microaveraging is
used; everything we will say in the rest of Section 7 may be adapted to the case of
macroaveraging in the obvious way.
7.1.2 Other measures of effectiveness. Measures alternative to p and ? and commonly used in the ML literature, such as accuracy (estimated as Aˆ =
T P +T N
T P +T N+F P +F N )
and error (estimated as Eˆ =
F P +F N
T P +T N+F P +F N = 1-Aˆ), are not widely used in TC.
The reason is that, as Yang [1999] points out, the large value that their denominator typically has in TC makes them much more insensitive to variations in the
number of correct decisions (T P + T N) than p and ?. Besides, if A is the adopted
evaluation measure, in the frequent case of a very low average generality the trivial
rejector (i.e. the classifier F such that F(dj , ci) = F for all dj and ci) tends to
outperform all non-trivial classifiers (see also [Cohen 1995a, Section 2.3]). If A is
adopted, parameter tuning on a validation set may thus result in parameter choices
that make the classifier behave very much like the trivial rejector.
A non-standard effectiveness measure is proposed by Sable and Hatzivassiloglou
[2000, Section 7], who suggest to base p and ? not on “absolute” values of success
and failure (i.e. 1 if F(dj , ci) = F( ? dj , ci) and 0 if F(dj , ci) 6= F( ? dj , ci)), but on values
of relative success (i.e. CSVi(dj ) if F( ? dj , ci) = T and 1 - CSVi(dj ) if F( ? dj , ci) =
F). This means that for a correct (resp. wrong) decision the classifier is rewarded
(resp. penalized) proportionally to its confidence in the decision. This proposed
measure does not reward the choice of a good thresholding policy, and is thus unfit
for autonomous (“hard”) classification systems. However, it might be appropriate
for interactive (“ranking”) classifiers of the type used in [Larkey 1999], where the
confidence that the classifier has in its own decision influences category ranking
and, as a consequence, the overall usefulness of the system.
7.1.3 Measures alternative to effectiveness. In general, criteria different from effectiveness are seldom used in classifier evaluation. For instance, efficiency, although very important for applicative purposes, is seldom used as the sole yardstick,
due to the volatility of the parameters on which the evaluation rests. However,
efficiency may be useful for choosing among classifiers with similar effectiveness.
An interesting evaluation has been carried out by Dumais et al. [1998], who have
compared five different learning methods along three different dimensions, namely
effectiveness, training efficiency (i.e. the average time it takes to build a classifier
for category ci from a training set T r), and classification efficiency (i.e. the average
time it takes to classify a new document dj under category ci).
An important alternative to effectiveness is utility, a class of measures from decision theory that extend effectiveness by economic criteria such as gain or loss.
Utility is based on a utility matrix such as that of Table 4, where the numeric values uT P , uF P , uF N and uT N represent the gain brought about by a true positive,
false positive, false negative and true negative, respectively; both uT P and uT N are
greater than both uF P and uF N . “Standard” effectiveness is a special case of utility, i.e. the one in which uT P = uT N > uF P = uF N . Less trivial cases are those in
which uT P 6= uT N and/or uF P 6= uF N ; this is the case e.g. in spam filtering, where
failing to discard a piece of junk mail (FP) is a less serious mistake than discarding
40 · F. Sebastiani
Category set expert judgments
C = {c1, . . . , c|C|} YES NO
classifier YES uTP uF P
judgments NO uF N uTN
Table 4. The utility matrix.
a legitimate message (FN) [Androutsopoulos et al. 2000]. If the classifier outputs
probability estimates of the membership of dj in ci
, then decision theory provides
analytical methods to determine thresholds ti
, thus avoiding the need to determine
them experimentally (as discussed in Section 6.1). Specifically, as Lewis [1995a]
reminds, the expected value of utility is maximized when
ti =
(uF P - uT N )
(uF N - uT P ) + (uF P - uT N )
which, in the case of “standard” effectiveness, is equal to 1
2
.
The use of utility in TC is discussed in detail by Lewis [1995a]. Other works
where utility is employed are [Amati and Crestani 1999; Cohen and Singer 1999;
Hull et al. 1996; Lewis and Catlett 1994; Schapire et al. 1998]. Utility has become
popular within the text filtering community, and the TREC “filtering track” evaluations have been using it since long [Lewis 1995c]. The values of the utility matrix
are extremely application-dependent. This means that if utility is used instead of
“pure” effectiveness, there is a further element of difficulty in the cross-comparison
of classification systems (see Section 7.3), since for two classifiers to be experimentally comparable also the two utility matrices must be the same.
Other effectiveness measures different from the ones discussed here have occasionally been used in the literature; these include adjacent score [Larkey 1998],
coverage [Schapire and Singer 2000], one-error [Schapire and Singer 2000], Pearson
product-moment correlation [Larkey 1998], recall at n [Larkey and Croft 1996], top
candidate [Larkey and Croft 1996], top n [Larkey and Croft 1996]. We will not
attempt to discuss them in detail. However, their use shows that, although the TC
community is making consistent efforts at standardising experimentation protocols,
we are still far from universal agreement on evaluation issues and, as a consequence,
from understanding precisely the relative merits of the various methods.
7.1.4 Combined effectiveness measures. Neither precision nor recall make sense
in isolation of each other. In fact the classifier F such that F(dj , ci) = T for all
dj and ci (the trivial acceptor ) has ? = 1. When the CSVi function has values in
[0, 1] one only needs to set every threshold ti to 0 to obtain the trivial acceptor. In
this case p would usually be very low (more precisely, equal to the average test set
generality
P|C|
i=1
gT e(ci)
|C| )
16. Conversely, it is well-known from everyday IR practice
that higher levels of p may be obtained at the price of low values of ?.
16From this one might be tempted to infer, by symmetry, that the trivial rejector always has
p = 1. This is false, as p is undefined (the denominator is zero) for the trivial rejector (see Table
5). In fact, it is clear from its definition (p = TP
TP +F P ) that p depends only on how the positives
(T P + F P) are split between true positives T P and the false positives F P, and does not depend
Machine Learning in Automated Text Categorization · 41
Precision Recall C-precision C-recall
T P
T P + F P
T P
T P + F N
T N
F P + T N
T N
T N + F N
Trivial Rejector TP=FP=0 undefined
0
F N
= 0
T N
T N
= 1
T N
T N + F N
Trivial Acceptor FN=TN=0 T P
T P + F P
T P
T P
= 1
0
F P
= 0 undefined
Trivial “Yes” Collection FP=TN=0
T P
T P
= 1
T P
T P + F N
undefined
0
F N
= 0
Trivial “No” Collection TP=FN=0 0
F P
= 0 undefined T N
F P + T N
T N
T N
= 1
Table 5. Trivial cases in TC.
In practice, by tuning ti a function CSVi
: D ? {T, F} is tuned to be, in the
words of Riloff and Lehnert [1994], more liberal (i.e. improving ?i to the detriment
of pi) or more conservative (improving pi to the detriment of ?i)
17. A classifier
should thus be evaluated by means of a measure which combines p and ?
18. Various
such measures have been proposed, among which the most frequent are:
(1) 11-point average precision: threshold ti
is repeatedly tuned so as to allow ?i
to take up values of 0.0, .1, . . . , .9, 1.0; pi
is computed for these 11 different
values of ti
, and averaged over the 11 resulting values. This is analogous to the
standard evaluation methodology for ranked IR systems, and may be used
(a) with categories in place of IR queries. This is most frequently used for
document-ranking classifiers (see e.g [Sch¨utze et al. 1995; Yang 1994; Yang
1999; Yang and Pedersen 1997]);
(b) with test documents in place of IR queries and categories in place of documents. This is most frequently used for category-ranking classifiers (see
e.g. [Lam et al. 1999; Larkey and Croft 1996; Schapire and Singer 2000;
Wiener et al. 1995]). In this case if macroaveraging is used it needs to be
redefined on a per-document, rather than per-category basis.
This measure does not make sense for binary-valued CSVi functions, since in
this case ?i may not be varied at will.
at all on the cardinality of the positives. There is a breakup of “symmetry” between p and ?
here because, from the point of view of classifier judgment (positives vs. negatives; this is the
dichotomy of interest in trivial acceptor vs. trivial rejector) the “symmetric” of ? (
TP
TP +F N ) is not
p (
TP
TP +F P ) but c-precision (p
c = TN
F P +TN ), the “contrapositive” of p. In fact, while ?=1 and
p
c=0 for the trivial acceptor, p
c=1 and ?=0 for the trivial rejector.
17While ?i can always be increased at will by lowering ti, usually at the cost of decreasing pi,
pi can usually be increased at will by raising ti, always at the cost of decreasing ?i. This kind of
tuning is only possible for CSVi functions with values in [0, 1]; for binary-valued CSVi functions
tuning is not always possible, or is anyway more difficult (see e.g. [Weiss et al. 1999, page 66]).
18An exception is single-label TC, in which p and ? are not independent of each other: if a
document dj has been classified under a wrong category cs (thus decreasing ps) this also means
that it has not been classified under the right category ct (thus decreasing ?t). In this case either
p or ? can be used as a measure of effectiveness.
42 · F. Sebastiani
(2) the breakeven point, i.e. the value at which p equals ? (e.g. [Apt´e et al. 1994;
Cohen and Singer 1999; Dagan et al. 1997; Joachims 1998; Joachims 1999;
Lewis 1992a; Lewis and Ringuette 1994; Moulinier and Ganascia 1996; Ng
et al. 1997; Yang 1999]). This is obtained by a process analogous to the one
used for 11-point average precision: a plot of p as a function of ? is computed
by repeatedly varying the thresholds ti
; breakeven is the value of ? (or p) for
which the plot intersects the ? = p line. This idea relies on the fact that by
decreasing the ti
’s from 1 to 0, ? always increases monotonically from 0 to 1
and p usually decreases monotonically from a value near 1 to 1
|C|
P|C|
i=1 gT e(ci).
If for no values of the ti
’s p and ? are exactly equal, the ti
’s are set to the
value for which p and ? are closest, and an interpolated breakeven is computed
as the average of the values of p and ?
19
.
(3) the Fß function [van Rijsbergen 1979, Chapter 7], for some 0 = ß = +8 (e.g.
[Cohen 1995a; Cohen and Singer 1999; Lewis and Gale 1994; Lewis 1995a;
Moulinier et al. 1996; Ruiz and Srinivasan 1999]), where
Fß =
(ß
2 + 1)p?
ß
2p + ?
Here ß may be seen as the relative degree of importance attributed to p and ?.
If ß = 0 then Fß coincides with p, whereas if ß = +8 then Fß coincides with
?. Usually, a value ß = 1 is used, which attributes equal importance to p and
?. As shown in [Moulinier et al. 1996; Yang 1999], the breakeven of a classifier
F is always less or equal than its F1 value.
Once an effectiveness measure is chosen, a classifier can be tuned (e.g. thresholds
and other parameters can be set) so that the resulting effectiveness is the best
achievable by that classifier. Tuning a parameter p (be it a threshold or other)
is normally done experimentally. This means performing repeated experiments on
the validation set with the values of the other parameters pk fixed (at a default
value, in the case of a yet-to-be-tuned parameter pk, or at the chosen value, if the
parameter pk has already been tuned) and with different values for parameter p.
The value that has yielded the best effectiveness is chosen for p.
7.2 Benchmarks for text categorization
Standard benchmark collections that can be used as initial corpora for TC are
publically available for experimental purposes. The most widely used is the Reuters
collection, consisting of a set of newswire stories classified under categories related
to economics. The Reuters collection accounts for most of the experimental work in
TC so far. Unfortunately, this does not always translate into reliable comparative
19Breakeven, first proposed by Lewis [1992a, 1992b], has been recently criticized. Lewis himself
(see his message of 11 Sep 1997 10:49:01 to the DDLBETA text categorization mailing list – quoted
with permission of the author) points out that breakeven is not a good effectiveness measure, since
(i) there may be no parameter setting that yields the breakeven; in this case the final breakeven
value, obtained by interpolation, is artificial; (ii) to have ? equal p is not necessarily desirable,
and it is not clear that a system that achieves high breakeven can be tuned to score high on other
effectiveness measures. Yang [1999] also notes that when for no value of the parameters p and ?
are close enough, interpolated breakeven may not be a reliable indicator of effectiveness.
Machine Learning in Automated Text Categorization · 43
results, in the sense that many of these experiments have been carried out in subtly
different conditions.
In general, different sets of experiments may be used for cross-classifier comparison only if the experiments have been performed
(1) on exactly the same collection (i.e. same documents and same categories);
(2) with the same “split” between training set and test set;
(3) with the same evaluation measure and, whenever this measure depends on some
parameters (e.g. the utility matrix chosen), with the same parameter values.
Unfortunately, a lot of experimentation, both on Reuters and on other collections,
has not been performed with these caveat in mind: by testing three different classifiers on five popular versions of Reuters, Yang [1999] has shown that a lack of
compliance with these three conditions may make the experimental results hardly
comparable among each other. Table 6 lists the results of all experiments known
to us performed on five major versions of the Reuters benchmark: Reuters-22173
“ModLewis” (column #1), Reuters-22173 “ModApt´e” (column #2), Reuters-22173
“ModWiener” (column #3), Reuters-21578 “ModApt´e” (column #4) and Reuters21578[10] “ModApt´e” (column #5)20. Only experiments that have computed either
a breakeven or F1 have been listed, since other less popular effectiveness measures
do not readily compare with these.
Note that only results belonging to the same column are directly comparable.
In particular, Yang [1999] showed that experiments carried out on Reuters-22173
“ModLewis” (column #1) are not directly comparable with those using the other
three versions, since the former strangely includes a significant percentage (58%)
of “unlabelled” test documents which, being negative examples of all categories,
tend to depress effectiveness. Also, experiments performed on Reuters-21578[10]
“ModApt´e” (column #5) are not comparable with the others, since this collection
is the restriction of Reuters-21578 “ModApt´e” to the 10 categories with the highest
generality, and is thus an obviously “easier” collection.
Other test collections that have been frequently used are
—the OHSUMED collection, set up by Hersh et al. [1994] and used in [Joachims
1998; Lam and Ho 1998; Lam et al. 1999; Lewis et al. 1996; Ruiz and Srinivasan 1999; Yang and Pedersen 1997]21. The documents are titles or title-plusabstract’s from medical journals (OHSUMED is actually a subset of the Medline
document base); the categories are the “postable terms” of the MESH thesaurus.
—the 20 Newsgroups collection, set up by Lang [1995] and used in [Baker and
McCallum 1998; Joachims 1997; McCallum and Nigam 1998; McCallum et al.
1998; Nigam et al. 2000; Schapire and Singer 2000]. The documents are messages
posted to Usenet newsgroups, and the categories are the newsgroups themselves.
20 The Reuters-21578 collection may be freely downloaded for experimentation purposes from
http://www.research.att.com/~lewis/reuters21578.html and is now considered the “standard”
variant of Reuters. We do not cover experiments performed on variants of Reuters different from the
five listed because the small number of authors that have used the same variant makes the reported
results difficult to interpret. This includes experiments performed on the original Reuters-22173
“ModHayes” [Hayes et al. 1990] and Reuters-21578 “ModLewis” [Cohen and Singer 1999].
21The OHSUMED collection may be freely downloaded for experimentation purposes from
ftp://medir.ohsu.edu/pub/ohsumed
44 · F. Sebastiani
#1 #2 #3 #4 #5
# of documents 21,450 14,347 13,272 12,902 12,902
# of training documents 14,704 10,667 9,610 9,603 9,603
# of test documents 6,746 3,680 3,662 3,299 3,299
# of categories 135 93 92 90 10
System Type Results reported by
Word (non-learning) [Yang 1999] .150 .310 .290
probabilistic [Dumais et al. 1998] .752 .815
probabilistic [Joachims 1998] .720
probabilistic [Lam et al. 1997] .443 (MF1)
PropBayes probabilistic [Lewis 1992a] .650
Bim probabilistic [Li and Yamanishi 1999] .747
probabilistic [Li and Yamanishi 1999] .773
Nb probabilistic [Yang and Liu 1999] .795
decision trees [Dumais et al. 1998] .884
C4.5 decision trees [Joachims 1998] .794
Ind decision trees [Lewis and Ringuette 1994] .670
Swap-1 decision rules [Apt´e et al. 1994] .805
Ripper decision rules [Cohen and Singer 1999] .683 .811 .820
SleepingExperts decision rules [Cohen and Singer 1999] .753 .759 .827
Dl-Esc decision rules [Li and Yamanishi 1999] .820
Charade decision rules [Moulinier and Ganascia 1996] .738
Charade decision rules [Moulinier et al. 1996] .783 (F1)
Llsf regression [Yang 1999] .855 .810
Llsf regression [Yang and Liu 1999] .849
BalancedWinnow on-line linear [Dagan et al. 1997] .747 (M) .833 (M)
Widrow-Hoff on-line linear [Lam and Ho 1998] .822
Rocchio batch linear [Cohen and Singer 1999] .660 .748 .776
FindSim batch linear [Dumais et al. 1998] .617 .646
Rocchio batch linear [Joachims 1998] .799
Rocchio batch linear [Lam and Ho 1998] .781
Rocchio batch linear [Li and Yamanishi 1999] .625
Classi neural network [Ng et al. 1997] .802
Nnet neural network [Yang and Liu 1999] .838
neural network [Wiener et al. 1995] .820
Gis-W example-based [Lam and Ho 1998] .860
k-NN example-based [Joachims 1998] .823
k-NN example-based [Lam and Ho 1998] .820
k-NN example-based [Yang 1999] .690 .852 .820
k-NN example-based [Yang and Liu 1999] .856
SVM [Dumais et al. 1998] .870 .920
SvmLight SVM [Joachims 1998] .864
SvmLight SVM [Li and Yamanishi 1999] .841
SvmLight SVM [Yang and Liu 1999] .859
AdaBoost.MH committee [Schapire and Singer 2000] .860
committee [Weiss et al. 1999] .878
Bayesian net [Dumais et al. 1998] .800 .850
Bayesian net [Lam et al. 1997] .542 (MF1)
Table 6. Comparative results among different classifiers obtained on five different version of
Reuters. Unless otherwise noted, entries indicate the microaveraged breakeven point; within
parentheses, “M” indicates macroaveraging and “F1” indicates use of the F1 measure. Boldface indicates the best performer on the collection.
—the AP collection, used in [Cohen 1995a; Cohen 1995b; Cohen and Singer 1999;
Lewis and Catlett 1994; Lewis and Gale 1994; Lewis et al. 1996; Schapire and
Singer 2000; Schapire et al. 1998].
We will not cover the experiments performed on these collections for the same
reasons as those illustrated in Footnote 20, i.e. because in no case a significant
enough number of authors have used the same collection in the same experimental
conditions, thus making comparisons difficult.
7.3 Which text classifier is best?
The published experimental results, and especially those listed in Table 6, allow us
to attempt some considerations on the comparative performance of the TC methods
discussed. However, we have to bear in mind that comparisons are reliable only
when based on experiments performed by the same author under carefully controlled conditions. They are instead more problematic when they involve different
experiments performed by different authors. In this case various “background con-
Machine Learning in Automated Text Categorization · 45
ditions”, often extraneous to the learning algorithm itself, may influence the results.
These may include, among others, different choices in pre-processing (stemming,
etc.), indexing, dimensionality reduction, classifier parameter values, etc., but also
different standards of compliance with safe scientific practice (such as tuning parameters on the test set rather than on a separate validation set), which often are
not discussed in the published papers.
Two different methods may thus be applied for comparing classifiers [Yang 1999]:
—direct comparison: classifiers F' and F'' may be compared when they have been
tested on the same collection ?, usually by the same researchers and with the
same background conditions. This is the more reliable method.
—indirect comparison: classifiers F' and F'' may be compared when
(1) they have been tested on collections ?' and ?'', respectively, typically by
different researchers and hence with possibly different background conditions;
(2) one or more “baseline” classifiers F1, . . . , Fm have been tested on both ?'
and ?'' by the direct comparison method.
Test 2 gives an indication on the relative “hardness” of ?' and ?''; using this and
the results from Test 1 we may obtain an indication on the relative effectiveness
of F' and F''. For the reasons discussed above, this method is less reliable.
A number of interesting conclusions can be drawn from Table 6 by using these two
methods. Concerning the relative “hardness” of the five collections, if by ?' >
?
'' we indicate that ?'
is a harder collection that ?'', there seems to be enough
evidence that Reuters-22173 “ModLewis” » Reuters-22173 “ModWiener” > Reuters22173 “ModApt´e” ˜ Reuters-21578 “ModApt´e” > Reuters-21578[10] “ModApt´e”.
These facts are unsurprising; in particular, the first and the last inequalities are a
direct consequence of the peculiar characteristics of Reuters-22173 “ModLewis” and
Reuters-21578[10] “ModApt´e” discussed in Section 7.2.
Concerning the relative performance of the classifiers, remembering the considerations above we may attempt a few conclusions:
—Boosting-based classifier committees, support vector machines, example-based
methods, and regression methods deliver top-notch performance. There seems to
be no sufficient evidence to decidedly opt for either method; efficiency considerations or application-dependent issues might play a role in breaking the tie.
—Neural networks and on-line linear classifiers work very well, although slightly
worse than the previously mentioned methods.
—Batch linear classifiers (Rocchio) and probabilistic Na¨ive Bayes classifiers look
the worst of the learning-based classifiers. For Rocchio, these results confirm
earlier results by Sch¨utze et al. [1995], who had found three classifiers based on
linear discriminant analysis, linear regression, and neural networks, to perform
about 15% better than Rocchio. However, recent results by Schapire et al. [1998]
rank Rocchio along the best performers once near-positives are used in training.
—The data in Table 6 are hardly sufficient to say anything about decision trees.
However, the work by Dumais et al. [1998] in which a decision tree classifier was
shown to perform nearly as well as their top performing system (a SVM classifier)
will probably renew the interest in decision trees, an interest that had dwindled
46 · F. Sebastiani
after the unimpressive results reported in earlier literature [Cohen and Singer
1999; Joachims 1998; Lewis and Catlett 1994; Lewis and Ringuette 1994].
—By far the lowest performance is displayed by Word, a classifier implemented
by Yang [1999] and not including any learning component22
.
Concerning Word and no-learning classifiers, for completeness we should recall
that one of the highest effectiveness values reported in the literature for the Reuters
collection (a .90 breakeven) belongs to Construe, a manually constructed classifier. However, this classifier has never been tested on the standard variants of
Reuters mentioned in Table 6, and it is not clear [Yang 1999] whether the (small)
test set of Reuters-22173 “ModHayes” on which the .90 breakeven value was obtained was chosen randomly, as safe scientific practice would demand. Therefore,
the fact that this figure is indicative of the performance of Construe, and of the
manual approach it represents, has been convincingly questioned [Yang 1999].
It is important to bear in mind that the considerations above are not absolute
statements (if there may be any) on the comparative effectiveness of these TC
methods. One of the reasons is that a particular applicative context may exhibit
very different characteristics from the ones to be found in Reuters, and different
classifiers may respond differently to these characteristics. An experimental study
by Joachims [1998] involving support vector machines, k-NN, decision trees, Rocchio and Na¨ive Bayes, showed all these classifiers to have similar effectiveness on
categories with = 300 positive training examples each. The fact that this experiment involved the methods which have scored best (support vector machines, k-NN)
and worst (Rocchio and Na¨ive Bayes) according to Table 6 shows that applicative
contexts different from Reuters may well invalidate conclusions drawn on this latter.
Finally, a note is worth about statistical significance testing. Few authors have
gone to the trouble of validating their results by means of such tests. These tests
are useful for verifying how strongly the experimental results support the claim that
a given system F'
is better than another system F'', or for verifying how much a
difference in the experimental setup affects the measured effectiveness of a system
F. Hull [1994] and Sch¨utze et al. [1995] have been among the first to work in this
direction, validating their results by means of the Anova test and the Friedman
test; the former is aimed at determining the significance of the difference in effectiveness between two methods in terms of the ratio between this difference and the
effectiveness variability across categories, while the latter conducts a similar test by
using instead the rank positions of each method within a category. Yang and Liu
[1999] define a full suite of significance tests, some of which apply to microaveraged
and some to macroaveraged effectiveness. They apply them systematically to the
comparison between five different classifiers, and are thus able to infer fine-grained
conclusions about their relative effectiveness. For other examples of significance
testing in TC see [Cohen 1995a; Cohen 1995b; Cohen and Hirsh 1998; Joachims
1997; Koller and Sahami 1997; Lewis et al. 1996; Wiener et al. 1995].
22Word is based on the comparison between documents and category names, each treated as a
vector of weighted terms in the vector space model. Word was implemented by Yang with the
only purpose of determining the difference in effectiveness that adding a learning component to
a classifier brings about. Word is actually called STR in [Yang 1994; Yang and Chute 1994].
Another no-learning classifier is proposed in [Wong et al. 1996].
Machine Learning in Automated Text Categorization · 47
8. CONCLUSION
Automated TC is now a major research area within the information systems discipline, thanks to a number of factors
—Its domains of application are numerous and important, and given the proliferation of documents in digital form they are bound to increase dramatically in
both number and importance.
—It is indispensable in many applications in which the sheer number of the documents to be classified and the short response time required by the application
make the manual alternative implausible.
—It can improve the productivity of human classifiers in applications in which no
classification decision can be taken without a final human judgment [Larkey and
Croft 1996], by providing tools that quickly “suggest” plausible decisions.
—It has reached effectiveness levels comparable to those of trained professionals.
The effectiveness of manual TC is not 100% anyway [Cleverdon 1984] and, more
importantly, it is unlikely to be improved substantially by the progress of research.
The levels of effectiveness of automated TC are instead growing at a steady pace,
and even if they will likely reach a plateau well below the 100% level, this plateau
will probably be higher that the effectiveness levels of manual TC.
One of the reasons why from the early ’90s the effectiveness of text classifiers has
dramatically improved, is the arrival in the TC arena of ML methods that are
backed by strong theoretical motivations. Examples of these are multiplicative
weight updating (e.g. the Winnow family, Widrow-Hoff, etc.), adaptive resampling (e.g. boosting) and support vector machines, which provide a sharp contrast
with relatively unsophisticated and weak methods such as Rocchio. In TC, ML
researchers have found a challenging application, since datasets consisting of hundreds of thousands of documents and characterized by tens of thousands of terms
are widely available. This means that TC is a good benchmark for checking whether
a given learning technique can scale up to substantial sizes. In turn, this probably
means that the active involvement of the ML community in TC is bound to grow.
The success story of automated TC is also going to encourage an extension of its
methods and techniques to neighbouring fields of application. Techniques typical
of automated TC have already been extended successfully to the categorization of
documents expressed in slightly different media; for instance:
—very noisy text resulting from optical character recognition [Ittner et al. 1995;
Junker and Hoch 1998]. In their experiments Ittner et al. [1995] have found that,
by employing noisy texts also in the training phase (i.e. texts affected by the same
source of noise that is also at work in the test documents), effectiveness levels
comparable to those obtainable in the case of standard text can be achieved.
—speech transcripts [Myers et al. 2000; Schapire and Singer 2000]. For instance,
Schapire and Singer [2000] classify answers given to a phone operator’s request
“How may I help you?”, so as to be able to route the call to a specialized operator according to call type.
Concerning other more radically different media, the situation is not as bright (however, see [Lim 1999] for an interesting attempt at image categorization based on a
48 · F. Sebastiani
textual metaphor). The reason for this is that capturing real semantic content of
non-textual media by automatic indexing is still an open problem. While there are
systems that attempt to detect content e.g. in images by recognising shapes, colour
distributions and texture, the general problem of image semantics is still unsolved.
The main reason is that natural language, the language of the text medium, admits far fewer variations than the “languages” employed by the other media. For
instance, while the concept of a house can be “triggered” by relatively few natural
language expressions such as house, houses, home, housing, inhabiting, etc., it
can be triggered by far more images: the images of all the different houses that
exist, of all possible colours and shapes, viewed from all possible perspectives, from
all possible distances, etc. If we had solved the multimedia indexing problem in
a satisfactory way, the general methodology that we have discussed in this paper
for text would also apply to automated multimedia categorization, and there are
reasons to believe that the effectiveness levels could be as high. This only adds to
the common sentiment that more research in automated content-based indexing for
multimedia documents is needed.
Acknowledgements
This paper owes a lot to the suggestions and constructive criticism of Norbert Fuhr
and David Lewis. Thanks also to Umberto Straccia for comments on an earlier
draft and to Alessandro Sperduti for many fruitful discussions.
